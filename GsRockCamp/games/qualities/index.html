<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chord Qualities Quiz</title>
  <!--
  ver1.2.7:
  - 正解時挙動をDiatonicと完全一致
  - phase管理方式へ統一
  - streak自然終了方式へ変更
  - 正解演出フローを統一
  - 不要ロック処理削除
  -->

  <style>
    :root{
      --text:#111;
      --muted:#666;
      --line:#ddd;
      --bg:#fff;
      --card:#fff;
      --blue:#1d4ed8;
      --warn:#b91c1c;

      --btn-bg:#fff;
      --btn-on-border: 2px solid var(--blue);
      --btn-off-border: 1px solid var(--line);
      --btn-radius: 16px;

      --oct-font: 14px;
      --main-font: 16px;
      --title-font: 22px;

      --tap-min-h: 44px;
    }

    body{
      font-family:-apple-system, system-ui, "Segoe UI", sans-serif;
      margin:16px;
      color:var(--text);
      background:var(--bg);
      padding-bottom:140px;
    }

    .wrap{ max-width:820px; margin:0 auto; }

    h1{
      font-size:var(--title-font);
      margin:6px 0 6px;
      letter-spacing:.2px;
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .ver{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
    }

    .muted{ color:var(--muted); }

    .changelog{
      margin:0 0 12px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
    }
    .changelog-title{
      font-weight:900;
      margin:0 0 6px;
      color:var(--muted);
      font-size:12px;
    }
    .changelog ul{
      margin:0;
      padding-left:18px;
      color:#333;
      line-height:1.4;
      font-size:13px;
    }
    .changelog li{ margin:4px 0; }

    .box{
      padding:14px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
      margin-top:12px;
    }

    .block{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fafafa;
      margin-top:12px;
    }
    .block-title{
      font-weight:900;
      font-size:18px;
      margin:0 0 10px;
    }

    .opt-row{
      display:grid;
      grid-template-columns: minmax(160px, 1fr) minmax(160px, 1fr);
      gap:10px;
      align-items:stretch;
      margin-top:10px;
    }

    .btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:12px 14px;
      font-size:var(--main-font);
      border-radius:var(--btn-radius);
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; }
    .btn.on{ border: var(--btn-on-border); }

    .btn small{
      font-weight:900;
      color:var(--muted);
      letter-spacing:.3px;
    }

    .oct-pair{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .oct-btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:10px 10px;
      font-size:var(--oct-font);
      border-radius:999px;
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .oct-btn:active{ transform: translateY(1px); }
    .oct-btn[disabled]{ opacity:.45; }
    .oct-btn.on{ border: var(--btn-on-border); }

    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }

    button.ctrl{
      padding:12px 14px;
      font-size:16px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    button.ctrl:disabled{ opacity:.45; }
    #btnStart{
      flex: 1 1 220px;
      font-size:20px;
      padding:16px 18px;
    }

    .status{ margin-top:12px; font-weight:900; }
    .status.warn{ color: var(--warn); }

    .hintArea{
      margin-top:10px;
      padding:12px;
      border:1px dashed #aaa;
      border-radius:12px;
      display:none;
      background:#fafafa;
      white-space:pre-wrap;
      line-height:1.5;
    }

    .scorebar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      font-weight:900;
    }
    .accuracy.good{ color: var(--blue); }

    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
      gap:10px;
      margin-top:10px;
    }
    .choice{
      padding:14px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    .choice:disabled{ opacity:.45; }
    .choice.ok{ border-color:#2b8a3e; }
    .choice.ng{ border-color:#c92a2a; }

    .note{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
    }

    .backwrap{ margin-top: 12px; text-align:center; }
    a.backbtn{
      display:inline-block;
      padding:12px 14px;
      border:1px solid var(--line);
      border-radius:14px;
      text-decoration:none;
      color:var(--text);
      background:var(--card);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    a.backbtn:active{ transform: translateY(1px); }

    @media (max-width: 420px){
      .opt-row{ grid-template-columns: 1fr; }
      .oct-pair{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>
      Chord Qualities Quiz
      <span class="ver" id="verText">ver1.2.7</span>
    </h1>
    <div class="muted">C基準で、コードの「品質（キャラ）」を当てます。</div>

    <div class="changelog">
      <div class="changelog-title">開発中の仕様確認（主な修正点）</div>
      <ul>
        <li>ver1.2.7：正解時挙動をDiatonicと完全一致</li>
        <li>ver1.2.7：phase管理方式へ統一</li>
        <li>ver1.2.7：streak自然終了方式へ変更</li>
        <li>ver1.2.7：正解演出フローを統一</li>
        <li>ver1.2.7：不要ロック処理削除</li>
      </ul>
    </div>

    <div class="box">
      <div class="block" id="blk_basic">
        <div class="block-title">① BASIC：基本クオリティ</div>

        <div class="opt-row">
          <button class="btn" id="basic_activeBtn"><span>アクティブ</span><small id="basic_activeStat">ON</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="basic_octMinus">Oct-</button>
            <button class="oct-btn" id="basic_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="basic_invBtn"><span>転回形</span><small id="basic_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="block" id="blk_plus">
        <div class="block-title">② PLUS：追加クオリティ</div>

        <div class="opt-row">
          <button class="btn" id="plus_activeBtn"><span>アクティブ</span><small id="plus_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="plus_octMinus">Oct-</button>
            <button class="oct-btn" id="plus_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="plus_invBtn"><span>転回形</span><small id="plus_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="block" id="blk_hard">
        <div class="block-title">③ HARD：難度高め</div>

        <div class="opt-row">
          <button class="btn" id="hard_activeBtn"><span>アクティブ</span><small id="hard_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="hard_octMinus">Oct-</button>
            <button class="oct-btn" id="hard_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="hard_invBtn"><span>転回形</span><small id="hard_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="note">※ 転回形はボイシング差分を含みます。</div>

      <div class="opt-row">
        <button class="btn" id="sfxToggleBtn"><span>演出音</span><small id="sfxToggleStat">ON</small></button>
        <div></div>
      </div>

      <div class="btn-row">
        <button class="ctrl" id="btnStart">出題</button>
        <button class="ctrl" id="btnReplay" disabled>もう一回</button>
        <button class="ctrl" id="btnReveal" disabled>答え</button>
        <button class="ctrl" id="btnHint" disabled>ヒント</button>
        <button class="ctrl" id="btnC">C（基準音）</button>
      </div>

      <div id="status" class="status">まだ出題していません</div>
      <div id="hintArea" class="hintArea"></div>
    </div>

    <div class="box">
      <div style="font-weight:900;">選択肢</div>
      <div class="grid" id="opts"></div>
    </div>

    <div class="box">
      <div class="scorebar">
        <div>スコア： <span id="score">0</span>/<span id="total">0</span></div>
        <div id="accuracy" class="accuracy">正答率 00%</div>
      </div>
    </div>

    <div class="backwrap">
      <a class="backbtn" href="../../index.html">← ポータルに戻る</a>
    </div>
  </div>

  <script>
  (() => {
    const VER = "1.2.7";
    document.getElementById("verText").textContent = "ver" + VER;

    const AUDIO_BASE = "./audio/";
    const CACHE_BUSTER = "?v=" + encodeURIComponent(VER);
    const LOG_ENABLED = true;

    const SFX_CORRECT_DIR   = "../../assets/sound/correct/";
    const SFX_INCORRECT_DIR = "../../assets/sound/incorrect/";
    const SFX_STREAK5_DIR   = "../../assets/sound/streak/streak5/";
    const SFX_STREAK10_DIR  = "../../assets/sound/streak/streak10/";
    const SFX_BUSTER = "?v=" + encodeURIComponent(VER);

    const SFX_CORRECT_MANIFEST   = "manifest.json";
    const SFX_INCORRECT_MANIFEST = "manifest.json";
    const SFX_STREAK_MANIFEST    = "manifest.json";

    let SFX_CORRECT = [];
    let SFX_INCORRECT = [];
    let SFX_STREAK5 = [];
    let SFX_STREAK10 = [];

    const DEFAULT_SFX_CORRECT = ["correct.mp3"];
    const DEFAULT_SFX_INCORRECT = [
      "cheer1.mp3",
      "cheer2.mp3",
      "cheer3.mp3",
      "cheer4.mp3",
      "cheer5.mp3",
      "cheer6.mp3"
    ];
    const DEFAULT_SFX_STREAK5 = [
      "streak5_1.mp3",
      "streak5_2.mp3",
      "streak5_3.mp3",
      "streak5_4.mp3",
      "streak5_5.mp3",
      "streak5_6.mp3",
      "streak5_7.mp3",
      "streak5_8.mp3"
    ];
    const DEFAULT_SFX_STREAK10 = [
      "streak10_1.mp3",
      "streak10_2.mp3",
      "streak10_3.mp3",
      "streak10_4.mp3",
      "streak10_5.mp3"
    ];
    const SFX_BUZZER_A = "buzzerA.mp3";
    const SFX_BUZZER_B = "buzzerB.mp3";
    const SFX_CORRECT_FILE = "correct.mp3";
    const SFX_OPTION_KEY = "qualities_sfx_enhance";

    const BLOCKS = {
      basic: {
        label: "BASIC",
        chords: [
          {id:"C",label:"C",hint:"長3度のまっすぐな明るさ",inv:2},
          {id:"Cm",label:"Cm",hint:"短3度の影",inv:2},
          {id:"C7",label:"C7",hint:"行きたがるドミナント感",inv:3},
          {id:"Cm7",label:"Cm7",hint:"マイナー＋♭7",inv:3},
          {id:"Cmaj7",label:"CM7",hint:"Maj7の都会感",inv:3}
        ]
      },
      plus: {
        label: "PLUS",
        chords: [
          {id:"Csus4",label:"Csus4",hint:"3度を外した保留",inv:2},
          {id:"Cadd9",label:"Cadd9",hint:"開放的な9th",inv:3},
          {id:"Cdim",label:"Cdim",hint:"減5度の不安",inv:2},
          {id:"Caug",label:"Caug",hint:"増5度の浮遊",inv:2},
          {id:"CmM7",label:"CmM7",hint:"妖しい切なさ",inv:3}
        ]
      },
      hard: {
        label: "HARD",
        chords: [
          {id:"Csus2",label:"Csus2",hint:"軽い保留",inv:2},
          {id:"C7sus2",label:"C7sus2",hint:"行きたいが言い切らない",inv:3},
          {id:"C6",label:"C6",hint:"6thの温かさ",inv:3},
          {id:"Cm6",label:"Cm6",hint:"影に灯り",inv:3},
          {id:"C9",label:"C9",hint:"7より柔らかい濁り",inv:3},
          {id:"Cmaj9",label:"CM9",hint:"広く透明",inv:3},
          {id:"Cm9",label:"Cm9",hint:"影の広がり",inv:3},
          {id:"Cdim7",label:"Cdim7",hint:"回る不安",inv:3}
        ]
      }
    };

    const STATE = {
      basic: { active: true, octMinus: false, octPlus: false, inversion: false },
      plus: { active: false, octMinus: false, octPlus: false, inversion: false },
      hard: { active: false, octMinus: false, octPlus: false, inversion: false }
    };

    const ORDER = ["basic", "plus", "hard"];

    // phase: idle | answering
    let phase = "idle";
    let current = null;
    let questionTicket = 0;

    let score = 0;
    let total = 0;

    let winStreak = 0;
    let missStreak = 0;
    let sfxEnhanced = true;

    let warmupContext = null;
    let bufferCache = new Map();
    let masterGain = null;
    let questionBusGain = null;
    let sfxBusGain = null;
    let keepAliveSource = null;
    let keepAliveGain = null;
    let questionSource = null;
    let questionGain = null;
    let questionMuted = false;

    const $ = id => document.getElementById(id);
    const opts = $("opts");
    const status = $("status");
    const hintArea = $("hintArea");
    const scoreEl = $("score");
    const totalEl = $("total");
    const accuracyEl = $("accuracy");
    const sfxToggleBtn = $("sfxToggleBtn");
    const sfxToggleStat = $("sfxToggleStat");

    function updateAccuracy(){
      const acc = total === 0 ? 0 : Math.round(score / total * 100);
      accuracyEl.textContent = "正答率 " + String(acc).padStart(2,"0") + "%";
      accuracyEl.classList.toggle("good", acc >= 80);
    }

    const CHORD_TONES = {
      C: ["C","E","G"],
      Cm: ["C","Eb","G"],
      C7: ["C","E","G","Bb"],
      Cm7: ["C","Eb","G","Bb"],
      Cmaj7: ["C","E","G","B"],
      Csus4: ["C","F","G"],
      Cadd9: ["C","E","G","D"],
      Cdim: ["C","Eb","Gb"],
      Caug: ["C","E","G#"],
      CmM7: ["C","Eb","G","B"],
      Csus2: ["C","D","G"],
      C7sus2: ["C","D","G","Bb"],
      C6: ["C","E","G","A"],
      Cm6: ["C","Eb","G","A"],
      C9: ["C","E","Bb","D"],
      Cmaj9: ["C","E","B","D"],
      Cm9: ["C","Eb","Bb","D"],
      Cdim7: ["C","Eb","Gb","A"]
    };

    const ANSWER_VOICINGS = {
      "Cadd9_0": "C-E-G-D",
      "Cadd9_1": "E-G-C-D",
      "Cadd9_2": "G-C-D-E",
      "C9_0": "C-E-Bb-D",
      "C9_1": "E-Bb-C-D",
      "C9_2": "Bb-C-D-E",
      "C9_3": "D-C-E-Bb",
      "Cmaj9_0": "C-E-B-D",
      "Cmaj9_1": "E-B-C-D",
      "Cmaj9_2": "B-C-D-E",
      "Cmaj9_3": "D-E-B-C"
    };

    function pickRandom(arr){
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function loadSfxOption(){
      try{
        const saved = localStorage.getItem(SFX_OPTION_KEY);
        if (saved === "off") sfxEnhanced = false;
        if (saved === "on") sfxEnhanced = true;
      }catch(e){
        if (LOG_ENABLED) console.warn("localStorage利用不可のためSFX設定はデフォルトを使用します。");
      }
    }

    function saveSfxOption(){
      try{
        localStorage.setItem(SFX_OPTION_KEY, sfxEnhanced ? "on" : "off");
      }catch(e){
        if (LOG_ENABLED) console.warn("localStorageに保存できませんでした。");
      }
    }

    function syncSfxOption(){
      if (sfxToggleStat){
        sfxToggleStat.textContent = sfxEnhanced ? "ON" : "OFF";
      }
      if (sfxToggleBtn){
        sfxToggleBtn.classList.toggle("on", sfxEnhanced);
      }
    }

    function getVoicingText(chordId, inversion){
      const key = `${chordId}_${inversion}`;
      if (ANSWER_VOICINGS[key]) return ANSWER_VOICINGS[key];
      const tones = CHORD_TONES[chordId];
      if (!tones) return "";
      const rot = inversion % tones.length;
      const ordered = tones.slice(rot).concat(tones.slice(0, rot));
      return ordered.join("-");
    }

    async function loadJsonArray(url){
      try{
        const r = await fetch(url, { cache:"no-store" });
        if (!r.ok) return [];
        const data = await r.json();
        if (!Array.isArray(data)) return [];
        return data.filter(x => typeof x === "string" && x.toLowerCase().endsWith(".mp3"));
      }catch{
        return [];
      }
    }

    async function loadSfxLists(){
      const correctUrl = SFX_CORRECT_DIR + SFX_CORRECT_MANIFEST + SFX_BUSTER;
      const incorrectUrl = SFX_INCORRECT_DIR + SFX_INCORRECT_MANIFEST + SFX_BUSTER;
      const streak5Url = SFX_STREAK5_DIR + SFX_STREAK_MANIFEST + SFX_BUSTER;
      const streak10Url = SFX_STREAK10_DIR + SFX_STREAK_MANIFEST + SFX_BUSTER;

      const [c, w, s5, s10] = await Promise.all([
        loadJsonArray(correctUrl),
        loadJsonArray(incorrectUrl),
        loadJsonArray(streak5Url),
        loadJsonArray(streak10Url)
      ]);

      SFX_CORRECT = c.length > 0 ? c : DEFAULT_SFX_CORRECT.slice();
      SFX_INCORRECT = w.length > 0 ? w : DEFAULT_SFX_INCORRECT.slice();
      SFX_STREAK5 = s5.length > 0 ? s5 : DEFAULT_SFX_STREAK5.slice();
      SFX_STREAK10 = s10.length > 0 ? s10 : DEFAULT_SFX_STREAK10.slice();

      if (c.length === 0 || w.length === 0 || s5.length === 0 || s10.length === 0){
        const msg = [
          "SFX一覧（manifest.json）が見つからない/空です。",
          "フォールバックのリストで再生します。",
          "必要なら assets/sound/correct/manifest.json と",
          "assets/sound/incorrect/manifest.json と",
          "assets/sound/streak/streak5/manifest.json と",
          "assets/sound/streak/streak10/manifest.json を用意してください。"
        ].join("\n");
        console.warn(msg);
      }
    }

    function getActiveBlocks(){
      return ORDER.filter(key => STATE[key].active);
    }

    function getActiveChords(){
      const list = [];
      getActiveBlocks().forEach(key => {
        BLOCKS[key].chords.forEach(chord => list.push({ ...chord, blockKey: key }));
      });
      return list;
    }

    function getActiveOctaves(blockKey){
      const octs = [3];
      if(STATE[blockKey].octMinus) octs.unshift(2);
      if(STATE[blockKey].octPlus) octs.push(4);
      return octs;
    }

    function buildAudioPath(chordId, octave, inversion){
      const suffix = inversion ? `_inv${inversion}_${octave}.mp3` : `_${octave}.mp3`;
      return `${AUDIO_BASE}${octave}/${chordId}${suffix}`;
    }

    function withCache(path){
      return `${path}${CACHE_BUSTER}`;
    }

    function shuffleCandidates(candidates){
      const arr = candidates.slice();
      for(let i = arr.length - 1; i > 0; i -= 1){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildCandidates(chord){
      const octs = getActiveOctaves(chord.blockKey);
      const list = [];
      octs.forEach(oct => {
        const rootPath = buildAudioPath(chord.id, oct, 0);
        list.push({
          chord,
          octave: oct,
          inversion: 0,
          path: rootPath,
          url: withCache(rootPath)
        });
        if(STATE[chord.blockKey].inversion){
          for(let i = 1; i <= chord.inv; i += 1){
            const invPath = buildAudioPath(chord.id, oct, i);
            list.push({
              chord,
              octave: oct,
              inversion: i,
              path: invPath,
              url: withCache(invPath)
            });
          }
        }
      });
      return list;
    }

    function buildOptions(){
      opts.innerHTML = "";
      const chords = getActiveChords();
      chords.forEach(q => {
        const b = document.createElement("button");
        b.className = "choice";
        b.textContent = q.label;
        b.disabled = true;
        b.onclick = () => answer(q, b);
        opts.appendChild(b);
      });
    }

    function enableOptions(on){
      [...opts.children].forEach(b => b.disabled = !on);
    }

    async function ensureAudioContext(){
      try{
        if(!warmupContext){
          warmupContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(!masterGain){
          masterGain = warmupContext.createGain();
          masterGain.gain.value = 1;
          masterGain.connect(warmupContext.destination);
        }
        if(!questionBusGain){
          questionBusGain = warmupContext.createGain();
          questionBusGain.gain.value = 1;
          questionBusGain.connect(masterGain);
        }
        if(!sfxBusGain){
          sfxBusGain = warmupContext.createGain();
          sfxBusGain.gain.value = 1;
          sfxBusGain.connect(masterGain);
        }
        if(!keepAliveSource){
          const noiseBuffer = warmupContext.createBuffer(1, warmupContext.sampleRate * 2, warmupContext.sampleRate);
          const channelData = noiseBuffer.getChannelData(0);
          for(let i = 0; i < channelData.length; i += 1){
            channelData[i] = Math.random() * 2 - 1;
          }
          keepAliveGain = warmupContext.createGain();
          keepAliveGain.gain.value = Math.pow(10, -75 / 20);
          keepAliveGain.connect(masterGain);
          keepAliveSource = warmupContext.createBufferSource();
          keepAliveSource.buffer = noiseBuffer;
          keepAliveSource.loop = true;
          keepAliveSource.connect(keepAliveGain);
          keepAliveSource.start();
        }
        return warmupContext;
      }catch(e){
        if (LOG_ENABLED) console.warn("AudioContextの初期化に失敗しました。");
        return null;
      }
    }

    function unlockAudio(){
      try{
        if(!warmupContext){
          const AC = window.AudioContext || window.webkitAudioContext;
          if(!AC) return;
          warmupContext = new AC();
        }

        ensureAudioContext();

        if(warmupContext.state === "suspended"){
          warmupContext.resume();
        }

        const buffer = warmupContext.createBuffer(1, 1, 22050);
        const src = warmupContext.createBufferSource();
        src.buffer = buffer;
        src.connect(warmupContext.destination);
        src.start(0);
      }catch(e){
        if (LOG_ENABLED) console.warn("Audio unlockに失敗しました。", e);
      }
    }

    function stopChannel(channelName, fadeSec = 0){
      if (channelName !== "player" || !questionSource || !questionGain || !warmupContext) return;
      const src = questionSource;
      const gain = questionGain;
      const now = warmupContext.currentTime;
      gain.gain.cancelScheduledValues(now);

      if (fadeSec > 0){
        try{
          const current = (typeof gain.gain.value === "number") ? gain.gain.value : 1;
          gain.gain.setValueAtTime(current, now);
          gain.gain.linearRampToValueAtTime(0, now + fadeSec);
        }catch(e){
          try{ gain.gain.value = 0; }catch(_e){}
        }
        try{ src.stop(now + fadeSec + 0.02); }catch(e){}
        window.setTimeout(() => {
          try{ src.disconnect(); }catch(e){}
          try{ gain.disconnect(); }catch(e){}
        }, Math.ceil(fadeSec * 1000) + 40);
      }else{
        try{ src.stop(); }catch(e){}
        try{ src.disconnect(); }catch(e){}
        try{ gain.disconnect(); }catch(e){}
      }

      if (questionSource === src){
        questionSource = null;
        questionGain = null;
        questionMuted = false;
      }
    }

    async function loadBuffer(url){
      if (bufferCache.has(url)) return bufferCache.get(url);
      const ctx = await ensureAudioContext();
      if (!ctx) return null;
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) return null;
        const data = await res.arrayBuffer();
        const buf = await ctx.decodeAudioData(data);
        bufferCache.set(url, buf);
        return buf;
      }catch(e){
        return null;
      }
    }

    async function playSequence(url, durationMs, trackQuestion){
      const ctx = await ensureAudioContext();
      if (!ctx) return false;
      if (trackQuestion){
        stopChannel("player", 0);
        if (questionBusGain){
          const now = ctx.currentTime;
          questionBusGain.gain.cancelScheduledValues(now);
          questionBusGain.gain.setValueAtTime(1, now);
        }
      }

      const mainBuffer = await loadBuffer(url);
      if (!mainBuffer) return false;

      const now = ctx.currentTime;

      const mainSource = ctx.createBufferSource();
      const gainNode = ctx.createGain();
      mainSource.buffer = mainBuffer;
      if (trackQuestion){
        mainSource.connect(gainNode).connect(questionBusGain);
      }else{
        mainSource.connect(gainNode).connect(sfxBusGain);
      }
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(1, now + 0.008);
      mainSource.start(now);
      if (durationMs){
        mainSource.stop(now + durationMs / 1000);
      }
      if (trackQuestion){
        questionSource = mainSource;
        questionGain = gainNode;
        questionMuted = false;
        mainSource.onended = () => {
          if (questionSource === mainSource){
            questionSource = null;
            questionGain = null;
            questionMuted = false;
          }
        };
      }
      return true;
    }

    async function playAudio(url){
      return playSequence(url, null, true);
    }

    async function playHintAudio(url){
      return playSequence(url, null, false);
    }

    async function playSnippet(url, durationMs){
      if(!url) return false;
      const ctx = await ensureAudioContext();
      if (!ctx) return false;
      const buffer = await loadBuffer(url);
      if (!buffer) return false;
      const source = ctx.createBufferSource();
      const gainNode = ctx.createGain();
      const now = ctx.currentTime;
      source.buffer = buffer;
      source.connect(gainNode).connect(sfxBusGain);
      gainNode.gain.setValueAtTime(1, now);
      if (durationMs && durationMs > 100){
        const fadeStart = now + (durationMs - 100) / 1000;
        gainNode.gain.setValueAtTime(1, fadeStart);
        gainNode.gain.linearRampToValueAtTime(0, now + durationMs / 1000);
      }
      source.start(now);
      if (durationMs){
        source.stop(now + durationMs / 1000);
      }
      return true;
    }

    async function playSfx(list, dir){
      if (!list || list.length === 0) return false;
      const f = pickRandom(list);
      const url = dir + f + SFX_BUSTER;
      return playSequence(url, null, false);
    }

    async function playFixedSfx(file, dir, durationMs){
      const url = dir + file + SFX_BUSTER;
      return playSequence(url, durationMs, false);
    }

    function playCorrectSfx(questionUrl){
      if (!sfxEnhanced){
        playFixedSfx(SFX_CORRECT_FILE, SFX_CORRECT_DIR).catch(() => {});
        return;
      }

      playSnippet(questionUrl, 500).catch(() => {});
      if (winStreak === 5){
        playSfx(SFX_STREAK5, SFX_STREAK5_DIR).catch(() => {});
      }else if (winStreak % 10 === 0){
        playSfx(SFX_STREAK10, SFX_STREAK10_DIR).catch(() => {});
      }

      playSnippet(questionUrl, 500).catch(() => {});
    }

    async function playIncorrectSfx(){
      if (!sfxEnhanced){
        await playFixedSfx(SFX_BUZZER_A, SFX_INCORRECT_DIR);
        return;
      }

      if (missStreak === 1){
        await playFixedSfx(SFX_BUZZER_A, SFX_INCORRECT_DIR);
        return;
      }
      if (missStreak === 2){
        await playFixedSfx(SFX_BUZZER_B, SFX_INCORRECT_DIR);
        return;
      }
      await playSfx(SFX_INCORRECT, SFX_INCORRECT_DIR);
    }

    function logSelection(candidate){
      if(!LOG_ENABLED) return;
      console.log("[qualities] octave:", candidate.octave, "chordId:", candidate.chord.id, "url:", candidate.url);
    }

    function formatPath(path){
      return path.startsWith("./") ? path.slice(2) : path;
    }

    function renderAudioError(details){
      const chordLabel = details.inversion
        ? `${details.chordId}_inv${details.inversion}`
        : details.chordId;
      const tried = details.triedPaths.slice(0, 10).map(path => `<li>${formatPath(path)}</li>`).join("");
      const triedBlock = tried ? `
        <details>
          <summary>試行候補 (${details.triedPaths.length}件)</summary>
          <ul>${tried}</ul>
        </details>` : "";

      const fallbackLine = details.fallbackPath
        ? `<div>フォールバック: ${formatPath(details.fallbackPath)}</div>`
        : "";

      status.innerHTML = `
        <div>音源が見つかりません。再試行してください。</div>
        <div>ChordID: ${chordLabel}</div>
        <div>Oct: ${details.octave}</div>
        <div>参照パス: ${formatPath(details.path)}</div>
        ${fallbackLine}
        ${triedBlock}
      `;
      status.classList.add("warn");
    }

    async function tryPlayQuestionCandidates(chosenChord, candidates, ticket, triedPaths, fallbackPath){
      let lastTried = candidates[0] || null;
      for (const candidate of candidates){
        if (ticket !== questionTicket || phase !== "answering" || !current || current.chord.id !== chosenChord.id){
          return;
        }
        lastTried = candidate;
        const played = await playAudio(candidate.url);
        if (ticket !== questionTicket || phase !== "answering" || !current || current.chord.id !== chosenChord.id){
          if (played) stopChannel("player", 0);
          return;
        }
        if (played){
          current.audioUrl = candidate.url;
          current.octave = candidate.octave;
          current.inversion = candidate.inversion;
          logSelection(candidate);
          return;
        }
      }

      if (ticket !== questionTicket || phase !== "answering" || !current || current.chord.id !== chosenChord.id){
        return;
      }

      renderAudioError({
        chordId: chosenChord.id,
        inversion: lastTried ? lastTried.inversion : 0,
        octave: lastTried ? lastTried.octave : 3,
        path: lastTried ? lastTried.path : fallbackPath,
        fallbackPath,
        triedPaths
      });
      phase = "idle";
      current = null;
      enableOptions(false);
      $("btnStart").disabled = false;
      $("btnReplay").disabled = true;
      $("btnHint").disabled = true;
      $("btnReveal").disabled = true;
    }

    function start(){
      const chords = getActiveChords();
      if(chords.length === 0){
        status.textContent = "アクティブなセットがありません。";
        status.classList.add("warn");
        return;
      }

      const chosenChord = chords[Math.floor(Math.random() * chords.length)];
      const baseCandidates = buildCandidates(chosenChord);
      const fallbackPath = buildAudioPath(chosenChord.id, 3, 0);
      const fallbackCandidate = {
        chord: chosenChord,
        octave: 3,
        inversion: 0,
        path: fallbackPath,
        url: withCache(fallbackPath)
      };
      const allCandidates = baseCandidates.some(c => c.url === fallbackCandidate.url)
        ? baseCandidates.slice()
        : baseCandidates.concat([fallbackCandidate]);
      const orderedCandidates = shuffleCandidates(allCandidates);
      const selected = orderedCandidates[0] || fallbackCandidate;
      const triedPaths = orderedCandidates.map(candidate => candidate.path);

      current = {
        chord: selected.chord,
        audioUrl: fallbackCandidate.url,
        octave: fallbackCandidate.octave,
        inversion: fallbackCandidate.inversion
      };

      phase = "answering";
      questionTicket += 1;
      const ticket = questionTicket;

      status.textContent = "出題中";
      status.classList.remove("warn");
      hintArea.style.display = "none";
      hintArea.textContent = "";
      [...opts.children].forEach(b => b.classList.remove("ok", "ng"));
      enableOptions(true);
      $("btnStart").disabled = true;
      $("btnReplay").disabled = false;
      $("btnHint").disabled = false;
      $("btnReveal").disabled = false;

      tryPlayQuestionCandidates(chosenChord, orderedCandidates, ticket, triedPaths, fallbackPath).catch(() => {});
    }

    function endQuestion(){
      phase = "idle";
      current = null;
      enableOptions(false);
      $("btnStart").disabled = false;
      $("btnReplay").disabled = true;
      $("btnHint").disabled = true;
      $("btnReveal").disabled = true;
    }

    async function answer(choice, btn){
      if(phase !== "answering" || !current) return;

      total += 1;
      totalEl.textContent = total;

      if(choice.id === current.chord.id){
        score += 1;
        winStreak += 1;
        missStreak = 0;
        scoreEl.textContent = score;
        updateAccuracy();
        status.textContent = `正解！ 答え：${current.chord.label} (${getVoicingText(current.chord.id, current.inversion)})`;
        questionTicket += 1;
        stopChannel("player", 0.2);
        playCorrectSfx(current.audioUrl);
        endQuestion();
      }else{
        missStreak += 1;
        winStreak = 0;
        updateAccuracy();
        status.textContent = "不正解… 再挑戦しますか？";
        $("btnStart").disabled = true;
        enableOptions(true);
        await playIncorrectSfx();
      }
    }

    $("btnStart").onclick = () => {
      if (phase !== "idle") return;
      unlockAudio();
      start();
    };

    $("btnReplay").onclick = () => {
      if(!current || phase !== "answering") return;
      playAudio(current.audioUrl);
    };

    $("btnReveal").onclick = () => {
      if(!current || phase !== "answering") return;
      status.textContent = `答え：${current.chord.label} (${getVoicingText(current.chord.id, current.inversion)})`;
      endQuestion();
    };

    $("btnHint").onclick = () => {
      if(!current || phase !== "answering") return;
      hintArea.textContent = current.chord.hint;
      hintArea.style.display = "block";
    };

    $("btnC").onclick = () => {
      unlockAudio();
      const basePath = buildAudioPath("C", 3, 0);
      playAudio(withCache(basePath));
    };

    function applyToggle(btn, statEl, isOn){
      btn.classList.toggle("on", isOn);
      if(statEl){
        statEl.textContent = isOn ? "ON" : "OFF";
      }
    }

    function bindBlockControls(blockKey){
      const activeBtn = $(`${blockKey}_activeBtn`);
      const activeStat = $(`${blockKey}_activeStat`);
      const invBtn = $(`${blockKey}_invBtn`);
      const invStat = $(`${blockKey}_invStat`);
      const octMinusBtn = $(`${blockKey}_octMinus`);
      const octPlusBtn = $(`${blockKey}_octPlus`);

      applyToggle(activeBtn, activeStat, STATE[blockKey].active);
      applyToggle(invBtn, invStat, STATE[blockKey].inversion);
      applyToggle(octMinusBtn, null, STATE[blockKey].octMinus);
      applyToggle(octPlusBtn, null, STATE[blockKey].octPlus);

      activeBtn.onclick = () => {
        STATE[blockKey].active = !STATE[blockKey].active;
        applyToggle(activeBtn, activeStat, STATE[blockKey].active);
        buildOptions();
        status.textContent = "セット変更しました";
        status.classList.remove("warn");
      };

      invBtn.onclick = () => {
        STATE[blockKey].inversion = !STATE[blockKey].inversion;
        applyToggle(invBtn, invStat, STATE[blockKey].inversion);
      };

      octMinusBtn.onclick = () => {
        STATE[blockKey].octMinus = !STATE[blockKey].octMinus;
        applyToggle(octMinusBtn, null, STATE[blockKey].octMinus);
      };

      octPlusBtn.onclick = () => {
        STATE[blockKey].octPlus = !STATE[blockKey].octPlus;
        applyToggle(octPlusBtn, null, STATE[blockKey].octPlus);
      };
    }

    loadSfxOption();
    loadSfxLists();
    ORDER.forEach(bindBlockControls);
    syncSfxOption();
    sfxToggleBtn.addEventListener("click", () => {
      sfxEnhanced = !sfxEnhanced;
      saveSfxOption();
      syncSfxOption();
    });
    document.body.addEventListener("touchstart", unlockAudio, { once: true });
    document.body.addEventListener("touchend", unlockAudio, { once: true });
    document.body.addEventListener("mousedown", unlockAudio, { once: true });
    document.body.addEventListener("pointerdown", unlockAudio, { once: true });
    document.body.addEventListener("click", unlockAudio, { once: true });
    buildOptions();
  })();
  </script>
</body>
</html>
