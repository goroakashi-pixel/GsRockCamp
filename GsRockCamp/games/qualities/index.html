<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chord Qualities Quiz</title>
  <!--
  ver1.2.4:
  - 正解演出を出題音のみで再生（Correct音なし）
  - 答え表示をステータス欄に統合
  - 演出音のON/OFF切替を追加
  -->

  <style>
    :root{
      --text:#111;
      --muted:#666;
      --line:#ddd;
      --bg:#fff;
      --card:#fff;
      --blue:#1d4ed8;
      --warn:#b91c1c;

      --btn-bg:#fff;
      --btn-on-border: 2px solid var(--blue);
      --btn-off-border: 1px solid var(--line);
      --btn-radius: 16px;

      --oct-font: 14px;
      --main-font: 16px;
      --title-font: 22px;

      --tap-min-h: 44px;
    }

    body{
      font-family:-apple-system, system-ui, "Segoe UI", sans-serif;
      margin:16px;
      color:var(--text);
      background:var(--bg);
      padding-bottom:140px;
    }

    .wrap{ max-width:820px; margin:0 auto; }

    h1{
      font-size:var(--title-font);
      margin:6px 0 6px;
      letter-spacing:.2px;
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .ver{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
    }

    .muted{ color:var(--muted); }

    .changelog{
      margin:0 0 12px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
    }
    .changelog-title{
      font-weight:900;
      margin:0 0 6px;
      color:var(--muted);
      font-size:12px;
    }
    .changelog ul{
      margin:0;
      padding-left:18px;
      color:#333;
      line-height:1.4;
      font-size:13px;
    }
    .changelog li{ margin:4px 0; }

    .box{
      padding:14px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
      margin-top:12px;
    }

    .block{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fafafa;
      margin-top:12px;
    }
    .block-title{
      font-weight:900;
      font-size:18px;
      margin:0 0 10px;
    }

    .opt-row{
      display:grid;
      grid-template-columns: minmax(160px, 1fr) minmax(160px, 1fr);
      gap:10px;
      align-items:stretch;
      margin-top:10px;
    }

    .btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:12px 14px;
      font-size:var(--main-font);
      border-radius:var(--btn-radius);
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; }
    .btn.on{ border: var(--btn-on-border); }

    .btn small{
      font-weight:900;
      color:var(--muted);
      letter-spacing:.3px;
    }

    .oct-pair{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .oct-btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:10px 10px;
      font-size:var(--oct-font);
      border-radius:999px;
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .oct-btn:active{ transform: translateY(1px); }
    .oct-btn[disabled]{ opacity:.45; }
    .oct-btn.on{ border: var(--btn-on-border); }

    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }

    button.ctrl{
      padding:12px 14px;
      font-size:16px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    button.ctrl:disabled{ opacity:.45; }
    #btnStart{
      flex: 1 1 220px;
      font-size:20px;
      padding:16px 18px;
    }

    .status{ margin-top:12px; font-weight:900; }
    .status.warn{ color: var(--warn); }

    .hintArea{
      margin-top:10px;
      padding:12px;
      border:1px dashed #aaa;
      border-radius:12px;
      display:none;
      background:#fafafa;
      white-space:pre-wrap;
      line-height:1.5;
    }

    .scorebar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      font-weight:900;
    }
    .accuracy.good{ color: var(--blue); }

    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
      gap:10px;
      margin-top:10px;
    }
    .choice{
      padding:14px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    .choice:disabled{ opacity:.45; }
    .choice.ok{ border-color:#2b8a3e; }
    .choice.ng{ border-color:#c92a2a; }

    .note{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
    }

    .backwrap{ margin-top: 12px; text-align:center; }
    a.backbtn{
      display:inline-block;
      padding:12px 14px;
      border:1px solid var(--line);
      border-radius:14px;
      text-decoration:none;
      color:var(--text);
      background:var(--card);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    a.backbtn:active{ transform: translateY(1px); }

    @media (max-width: 420px){
      .opt-row{ grid-template-columns: 1fr; }
      .oct-pair{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>
      Chord Qualities Quiz
      <span class="ver" id="verText">ver1.2.4</span>
    </h1>
    <div class="muted">C基準で、コードの「品質（キャラ）」を当てます。</div>

    <div class="changelog">
      <div class="changelog-title">開発中の仕様確認（主な修正点）</div>
      <ul>
        <li>ver1.2.4：正解演出は出題音のみ（Correct音なし）</li>
        <li>ver1.2.4：答え表示をステータス欄へ移動</li>
        <li>ver1.2.4：演出音のON/OFF切替</li>
      </ul>
    </div>

    <div class="box">
      <div class="block" id="blk_basic">
        <div class="block-title">① BASIC：基本クオリティ</div>

        <div class="opt-row">
          <button class="btn" id="basic_activeBtn"><span>アクティブ</span><small id="basic_activeStat">ON</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="basic_octMinus">Oct-</button>
            <button class="oct-btn" id="basic_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="basic_invBtn"><span>転回形</span><small id="basic_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="block" id="blk_plus">
        <div class="block-title">② PLUS：追加クオリティ</div>

        <div class="opt-row">
          <button class="btn" id="plus_activeBtn"><span>アクティブ</span><small id="plus_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="plus_octMinus">Oct-</button>
            <button class="oct-btn" id="plus_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="plus_invBtn"><span>転回形</span><small id="plus_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="block" id="blk_hard">
        <div class="block-title">③ HARD：難度高め</div>

        <div class="opt-row">
          <button class="btn" id="hard_activeBtn"><span>アクティブ</span><small id="hard_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="hard_octMinus">Oct-</button>
            <button class="oct-btn" id="hard_octPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="hard_invBtn"><span>転回形</span><small id="hard_invStat">OFF</small></button>
          <div></div>
        </div>
      </div>

      <div class="note">※ 転回形はボイシング差分を含みます。</div>

      <div class="opt-row">
        <button class="btn" id="sfxToggleBtn"><span>演出音</span><small id="sfxToggleStat">ON</small></button>
        <div></div>
      </div>

      <div class="btn-row">
        <button class="ctrl" id="btnStart">出題</button>
        <button class="ctrl" id="btnReplay" disabled>もう一回</button>
        <button class="ctrl" id="btnReveal" disabled>答え</button>
        <button class="ctrl" id="btnHint" disabled>ヒント</button>
        <button class="ctrl" id="btnC">C（基準音）</button>
      </div>

      <div id="status" class="status">まだ出題していません</div>
      <div id="hintArea" class="hintArea"></div>
    </div>

    <div class="box">
      <div style="font-weight:900;">選択肢</div>
      <div class="grid" id="opts"></div>
    </div>

    <div class="box">
      <div class="scorebar">
        <div>スコア： <span id="score">0</span>/<span id="total">0</span></div>
        <div id="accuracy" class="accuracy">正答率 00%</div>
      </div>
    </div>

    <div class="backwrap">
      <a class="backbtn" href="../../index.html">← ポータルに戻る</a>
    </div>
  </div>

  <script>
  (() => {
    const VER = "1.2.4";
    document.getElementById("verText").textContent = "ver" + VER;

    const AUDIO_BASE = "./audio/";
    const CACHE_BUSTER = "?v=" + encodeURIComponent(VER);
    const LOG_ENABLED = true;

    const SFX_CORRECT_DIR   = "../../assets/sound/correct/";
    const SFX_INCORRECT_DIR = "../../assets/sound/incorrect/";
    const SFX_STREAK5_DIR   = "../../assets/sound/streak/streak5/";
    const SFX_STREAK10_DIR  = "../../assets/sound/streak/streak10/";
    const SFX_BUSTER = "?v=" + encodeURIComponent(VER);

    const SFX_CORRECT_MANIFEST   = "manifest.json";
    const SFX_INCORRECT_MANIFEST = "manifest.json";
    const SFX_STREAK_MANIFEST    = "manifest.json";

    let SFX_CORRECT = [];
    let SFX_INCORRECT = [];
    let SFX_STREAK5 = [];
    let SFX_STREAK10 = [];

    const DEFAULT_SFX_CORRECT = ["correct.mp3"];
    const DEFAULT_SFX_INCORRECT = [
      "cheer1.mp3",
      "cheer2.mp3",
      "cheer3.mp3",
      "cheer4.mp3",
      "cheer5.mp3",
      "cheer6.mp3"
    ];
    const DEFAULT_SFX_STREAK5 = [
      "streak5_1.mp3",
      "streak5_2.mp3",
      "streak5_3.mp3",
      "streak5_4.mp3",
      "streak5_5.mp3",
      "streak5_6.mp3",
      "streak5_7.mp3",
      "streak5_8.mp3"
    ];
    const DEFAULT_SFX_STREAK10 = [
      "streak10_1.mp3",
      "streak10_2.mp3",
      "streak10_3.mp3",
      "streak10_4.mp3",
      "streak10_5.mp3"
    ];
    const SFX_BUZZER_A = "buzzerA.mp3";
    const SFX_BUZZER_B = "buzzerB.mp3";
    const SFX_CORRECT_FILE = "correct.mp3";
    const SFX_OPTION_KEY = "qualities_sfx_enhance";

    const BLOCKS = {
      basic: {
        label: "BASIC",
        chords: [
          {id:"C",label:"C",hint:"長3度のまっすぐな明るさ",inv:2},
          {id:"Cm",label:"Cm",hint:"短3度の影",inv:2},
          {id:"C7",label:"C7",hint:"行きたがるドミナント感",inv:3},
          {id:"Cm7",label:"Cm7",hint:"マイナー＋♭7",inv:3},
          {id:"Cmaj7",label:"CM7",hint:"Maj7の都会感",inv:3}
        ]
      },
      plus: {
        label: "PLUS",
        chords: [
          {id:"Csus4",label:"Csus4",hint:"3度を外した保留",inv:2},
          {id:"Cadd9",label:"Cadd9",hint:"開放的な9th",inv:3},
          {id:"Cdim",label:"Cdim",hint:"減5度の不安",inv:2},
          {id:"Caug",label:"Caug",hint:"増5度の浮遊",inv:2},
          {id:"CmM7",label:"CmM7",hint:"妖しい切なさ",inv:3}
        ]
      },
      hard: {
        label: "HARD",
        chords: [
          {id:"Csus2",label:"Csus2",hint:"軽い保留",inv:2},
          {id:"C7sus2",label:"C7sus2",hint:"行きたいが言い切らない",inv:3},
          {id:"C6",label:"C6",hint:"6thの温かさ",inv:3},
          {id:"Cm6",label:"Cm6",hint:"影に灯り",inv:3},
          {id:"C9",label:"C9",hint:"7より柔らかい濁り",inv:3},
          {id:"Cmaj9",label:"CM9",hint:"広く透明",inv:3},
          {id:"Cm9",label:"Cm9",hint:"影の広がり",inv:3},
          {id:"Cdim7",label:"Cdim7",hint:"回る不安",inv:3}
        ]
      }
    };

    const STATE = {
      basic: { active: true, octMinus: false, octPlus: false, inversion: false },
      plus: { active: false, octMinus: false, octPlus: false, inversion: false },
      hard: { active: false, octMinus: false, octPlus: false, inversion: false }
    };

    const ORDER = ["basic", "plus", "hard"];

    let current = null;
    let locked = true;
    let pendingWrong = false;

    let score = 0;
    let total = 0;

    let winStreak = 0;
    let missStreak = 0;
    let sfxEnhanced = true;

    let warmupDone = false;
    let warmupContext = null;
    let muteBuffer = null;
    let activeSources = [];
    let bufferCache = new Map();
    const MUTE_URL = "../../assets/sound/system/mute.mp3";
    const sfxAudio = new Audio();
    const sfxVoiceAudio = new Audio();

    const $ = id => document.getElementById(id);
    const opts = $("opts");
    const status = $("status");
    const hintArea = $("hintArea");
    const scoreEl = $("score");
    const totalEl = $("total");
    const accuracyEl = $("accuracy");
    const sfxToggleBtn = $("sfxToggleBtn");
    const sfxToggleStat = $("sfxToggleStat");

    function updateAccuracy(){
      const acc = total === 0 ? 0 : Math.round(score / total * 100);
      accuracyEl.textContent = "正答率 " + String(acc).padStart(2,"0") + "%";
      accuracyEl.classList.toggle("good", acc >= 80);
    }

    const CHORD_TONES = {
      C: ["C","E","G"],
      Cm: ["C","Eb","G"],
      C7: ["C","E","G","Bb"],
      Cm7: ["C","Eb","G","Bb"],
      Cmaj7: ["C","E","G","B"],
      Csus4: ["C","F","G"],
      Cadd9: ["C","E","G","D"],
      Cdim: ["C","Eb","Gb"],
      Caug: ["C","E","G#"],
      CmM7: ["C","Eb","G","B"],
      Csus2: ["C","D","G"],
      C7sus2: ["C","D","G","Bb"],
      C6: ["C","E","G","A"],
      Cm6: ["C","Eb","G","A"],
      C9: ["C","E","Bb","D"],
      Cmaj9: ["C","E","B","D"],
      Cm9: ["C","Eb","Bb","D"],
      Cdim7: ["C","Eb","Gb","A"]
    };

    const ANSWER_VOICINGS = {
      "Cadd9_0": "C-E-G-D",
      "Cadd9_1": "E-G-C-D",
      "Cadd9_2": "G-C-D-E",
      "C9_0": "C-E-Bb-D",
      "C9_1": "E-Bb-C-D",
      "C9_2": "Bb-C-D-E",
      "C9_3": "D-C-E-Bb",
      "Cmaj9_0": "C-E-B-D",
      "Cmaj9_1": "E-B-C-D",
      "Cmaj9_2": "B-C-D-E",
      "Cmaj9_3": "D-E-B-C"
    };

    function pickRandom(arr){
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function loadSfxOption(){
      try{
        const saved = localStorage.getItem(SFX_OPTION_KEY);
        if (saved === "off") sfxEnhanced = false;
        if (saved === "on") sfxEnhanced = true;
      }catch(e){
        if (LOG_ENABLED) console.warn("localStorage利用不可のためSFX設定はデフォルトを使用します。");
      }
    }

    function saveSfxOption(){
      try{
        localStorage.setItem(SFX_OPTION_KEY, sfxEnhanced ? "on" : "off");
      }catch(e){
        if (LOG_ENABLED) console.warn("localStorageに保存できませんでした。");
      }
    }

    function syncSfxOption(){
      if (sfxToggleStat){
        sfxToggleStat.textContent = sfxEnhanced ? "ON" : "OFF";
      }
      if (sfxToggleBtn){
        sfxToggleBtn.classList.toggle("on", sfxEnhanced);
      }
    }

    function getVoicingText(chordId, inversion){
      const key = `${chordId}_${inversion}`;
      if (ANSWER_VOICINGS[key]) return ANSWER_VOICINGS[key];
      const tones = CHORD_TONES[chordId];
      if (!tones) return "";
      const rot = inversion % tones.length;
      const ordered = tones.slice(rot).concat(tones.slice(0, rot));
      return ordered.join("-");
    }

    async function loadJsonArray(url){
      try{
        const r = await fetch(url, { cache:"no-store" });
        if (!r.ok) return [];
        const data = await r.json();
        if (!Array.isArray(data)) return [];
        return data.filter(x => typeof x === "string" && x.toLowerCase().endsWith(".mp3"));
      }catch{
        return [];
      }
    }

    async function loadSfxLists(){
      const correctUrl = SFX_CORRECT_DIR + SFX_CORRECT_MANIFEST + SFX_BUSTER;
      const incorrectUrl = SFX_INCORRECT_DIR + SFX_INCORRECT_MANIFEST + SFX_BUSTER;
      const streak5Url = SFX_STREAK5_DIR + SFX_STREAK_MANIFEST + SFX_BUSTER;
      const streak10Url = SFX_STREAK10_DIR + SFX_STREAK_MANIFEST + SFX_BUSTER;

      const [c, w, s5, s10] = await Promise.all([
        loadJsonArray(correctUrl),
        loadJsonArray(incorrectUrl),
        loadJsonArray(streak5Url),
        loadJsonArray(streak10Url)
      ]);

      SFX_CORRECT = c.length > 0 ? c : DEFAULT_SFX_CORRECT.slice();
      SFX_INCORRECT = w.length > 0 ? w : DEFAULT_SFX_INCORRECT.slice();
      SFX_STREAK5 = s5.length > 0 ? s5 : DEFAULT_SFX_STREAK5.slice();
      SFX_STREAK10 = s10.length > 0 ? s10 : DEFAULT_SFX_STREAK10.slice();

      if (c.length === 0 || w.length === 0 || s5.length === 0 || s10.length === 0){
        const msg = [
          "SFX一覧（manifest.json）が見つからない/空です。",
          "フォールバックのリストで再生します。",
          "必要なら assets/sound/correct/manifest.json と",
          "assets/sound/incorrect/manifest.json と",
          "assets/sound/streak/streak5/manifest.json と",
          "assets/sound/streak/streak10/manifest.json を用意してください。"
        ].join("\n");
        console.warn(msg);
      }
    }

    function getActiveBlocks(){
      return ORDER.filter(key => STATE[key].active);
    }

    function getActiveChords(){
      const list = [];
      getActiveBlocks().forEach(key => {
        BLOCKS[key].chords.forEach(chord => list.push({ ...chord, blockKey: key }));
      });
      return list;
    }

    function getActiveOctaves(blockKey){
      const octs = [3];
      if(STATE[blockKey].octMinus) octs.unshift(2);
      if(STATE[blockKey].octPlus) octs.push(4);
      return octs;
    }

    function buildAudioPath(chordId, octave, inversion){
      const suffix = inversion ? `_inv${inversion}_${octave}.mp3` : `_${octave}.mp3`;
      return `${AUDIO_BASE}${octave}/${chordId}${suffix}`;
    }

    function withCache(path){
      return `${path}${CACHE_BUSTER}`;
    }

    async function checkUrl(url){
      try{
        const res = await fetch(url, { method: "HEAD" });
        return res.ok;
      }catch(e){
        return null;
      }
    }

    async function filterExistingCandidates(candidates){
      let hadError = false;
      const checks = await Promise.all(candidates.map(async candidate => {
        const ok = await checkUrl(candidate.url);
        if (ok === null) hadError = true;
        return ok ? candidate : null;
      }));
      return {
        available: checks.filter(Boolean),
        hadError
      };
    }

    function buildCandidates(chord){
      const octs = getActiveOctaves(chord.blockKey);
      const list = [];
      octs.forEach(oct => {
        const rootPath = buildAudioPath(chord.id, oct, 0);
        list.push({
          chord,
          octave: oct,
          inversion: 0,
          path: rootPath,
          url: withCache(rootPath)
        });
        if(STATE[chord.blockKey].inversion){
          for(let i = 1; i <= chord.inv; i += 1){
            const invPath = buildAudioPath(chord.id, oct, i);
            list.push({
              chord,
              octave: oct,
              inversion: i,
              path: invPath,
              url: withCache(invPath)
            });
          }
        }
      });
      return list;
    }

    function buildOptions(){
      opts.innerHTML = "";
      const chords = getActiveChords();
      chords.forEach(q => {
        const b = document.createElement("button");
        b.className = "choice";
        b.textContent = q.label;
        b.disabled = true;
        b.onclick = () => answer(q, b);
        opts.appendChild(b);
      });
    }

    function enableOptions(on){
      [...opts.children].forEach(b => b.disabled = !on);
    }

    async function ensureAudioContext(){
      try{
        if(!warmupContext){
          warmupContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if(warmupContext.state === "suspended"){
          await warmupContext.resume();
        }
        return warmupContext;
      }catch(e){
        if (LOG_ENABLED) console.warn("AudioContextの初期化に失敗しました。");
        return null;
      }
    }

    function stopActiveSources(){
      activeSources.forEach(source => {
        try{ source.stop(); }catch(e){}
        try{ source.disconnect(); }catch(e){}
      });
      activeSources = [];
    }

    async function loadBuffer(url){
      if (bufferCache.has(url)) return bufferCache.get(url);
      const ctx = await ensureAudioContext();
      if (!ctx) return null;
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) return null;
        const data = await res.arrayBuffer();
        const buf = await ctx.decodeAudioData(data);
        bufferCache.set(url, buf);
        return buf;
      }catch(e){
        return null;
      }
    }

    async function playSequence(url, durationMs){
      const ctx = await ensureAudioContext();
      if (!ctx) return false;
      stopActiveSources();

      if (!muteBuffer){
        muteBuffer = await loadBuffer(MUTE_URL);
        if (!muteBuffer && LOG_ENABLED){
          console.warn("mute.mp3が取得できませんでした。");
        }
      }

      const mainBuffer = await loadBuffer(url);
      if (!mainBuffer) return false;

      const now = ctx.currentTime;
      const startTime = now + 0.2;

      if (muteBuffer){
        const muteSource = ctx.createBufferSource();
        muteSource.buffer = muteBuffer;
        muteSource.connect(ctx.destination);
        muteSource.start(now);
        activeSources.push(muteSource);
      }

      const mainSource = ctx.createBufferSource();
      mainSource.buffer = mainBuffer;
      mainSource.connect(ctx.destination);
      mainSource.start(startTime);
      if (durationMs){
        mainSource.stop(startTime + durationMs / 1000);
      }
      activeSources.push(mainSource);
      return true;
    }

    async function playAudio(url){
      return playSequence(url);
    }

    async function playSnippet(url, durationMs){
      if(!url) return;
      await playSequence(url, durationMs);
    }

    async function playSfx(list, dir){
      if (!list || list.length === 0) return;
      const f = pickRandom(list);
      const url = dir + f + SFX_BUSTER;
      await playSequence(url);
    }

    async function playFixedSfx(file, dir, durationMs){
      const url = dir + file + SFX_BUSTER;
      await playSequence(url, durationMs);
    }

    function playImmediateSfx(url, audioEl){
      audioEl.pause();
      audioEl.currentTime = 0;
      audioEl.src = url;
      audioEl.play().catch(() => {});
    }

    async function playCorrectSfx(questionUrl){
      if (!sfxEnhanced){
        await playSnippet(questionUrl, 500);
        return;
      }
      await playSnippet(questionUrl, 500);
      if (winStreak === 5){
        if (SFX_STREAK5.length > 0){
          playImmediateSfx(SFX_STREAK5_DIR + pickRandom(SFX_STREAK5) + SFX_BUSTER, sfxVoiceAudio);
        }
      }else if (winStreak % 10 === 0){
        if (SFX_STREAK10.length > 0){
          playImmediateSfx(SFX_STREAK10_DIR + pickRandom(SFX_STREAK10) + SFX_BUSTER, sfxVoiceAudio);
        }
      }
    }

    async function playIncorrectSfx(){
      if (!sfxEnhanced){
        playImmediateSfx(SFX_INCORRECT_DIR + SFX_BUZZER_A + SFX_BUSTER, sfxAudio);
        return;
      }

      if (missStreak === 1){
        playImmediateSfx(SFX_INCORRECT_DIR + SFX_BUZZER_A + SFX_BUSTER, sfxAudio);
        return;
      }
      if (missStreak === 2){
        playImmediateSfx(SFX_INCORRECT_DIR + SFX_BUZZER_B + SFX_BUSTER, sfxAudio);
        return;
      }
      playImmediateSfx(SFX_INCORRECT_DIR + pickRandom(SFX_INCORRECT) + SFX_BUSTER, sfxAudio);
    }

    async function warmupAudio(){
      if(warmupDone) return;
      warmupDone = true;
      await ensureAudioContext();
    }

    function logSelection(candidate){
      if(!LOG_ENABLED) return;
      console.log("[qualities] octave:", candidate.octave, "chordId:", candidate.chord.id, "url:", candidate.url);
    }

    function formatPath(path){
      return path.startsWith("./") ? path.slice(2) : path;
    }

    function renderAudioError(details){
      const chordLabel = details.inversion
        ? `${details.chordId}_inv${details.inversion}`
        : details.chordId;
      const tried = details.triedPaths.slice(0, 10).map(path => `<li>${formatPath(path)}</li>`).join("");
      const triedBlock = tried ? `
        <details>
          <summary>試行候補 (${details.triedPaths.length}件)</summary>
          <ul>${tried}</ul>
        </details>` : "";

      const fallbackLine = details.fallbackPath
        ? `<div>フォールバック: ${formatPath(details.fallbackPath)}</div>`
        : "";

      status.innerHTML = `
        <div>音源が見つかりません。再試行してください。</div>
        <div>ChordID: ${chordLabel}</div>
        <div>Oct: ${details.octave}</div>
        <div>参照パス: ${formatPath(details.path)}</div>
        ${fallbackLine}
        ${triedBlock}
      `;
      status.classList.add("warn");
    }

    async function start(){
      const chords = getActiveChords();
      if(chords.length === 0){
        status.textContent = "アクティブなセットがありません。";
        status.classList.add("warn");
        return;
      }

      const chosenChord = chords[Math.floor(Math.random() * chords.length)];
      const candidates = buildCandidates(chosenChord);
      const referenceCandidate = candidates[0];
      const triedPaths = candidates.map(candidate => candidate.path);
      const { available, hadError } = await filterExistingCandidates(candidates);

      status.textContent = "出題中";
      status.classList.remove("warn");

      let selected = null;
      if(available.length > 0){
        selected = available[Math.floor(Math.random() * available.length)];
      }else if (hadError && candidates.length > 0){
        selected = candidates[Math.floor(Math.random() * candidates.length)];
      }else{
        const fallbackPath = buildAudioPath(chosenChord.id, 3, 0);
        const fallbackUrl = withCache(fallbackPath);
        const exists = await checkUrl(fallbackUrl);
        if(exists){
          selected = {
            chord: chosenChord,
            octave: 3,
            inversion: 0,
            path: fallbackPath,
            url: fallbackUrl
          };
        }else{
          renderAudioError({
            chordId: chosenChord.id,
            inversion: referenceCandidate ? referenceCandidate.inversion : 0,
            octave: referenceCandidate ? referenceCandidate.octave : 3,
            path: referenceCandidate ? referenceCandidate.path : fallbackPath,
            fallbackPath,
            triedPaths
          });
          locked = true;
          enableOptions(false);
          $("btnReplay").disabled = true;
          $("btnHint").disabled = true;
          $("btnReveal").disabled = true;
          return;
        }
      }

      const fallbackPath = buildAudioPath(chosenChord.id, 3, 0);
      const fallbackUrl = withCache(fallbackPath);
      const played = await playAudio(selected.url);
      if (!played){
        const fallbackPlayed = await playAudio(fallbackUrl);
        if (!fallbackPlayed){
          renderAudioError({
            chordId: chosenChord.id,
            inversion: selected.inversion,
            octave: selected.octave,
            path: selected.path,
            fallbackPath,
            triedPaths
          });
          locked = true;
          enableOptions(false);
          $("btnReplay").disabled = true;
          $("btnHint").disabled = true;
          $("btnReveal").disabled = true;
          return;
        }
        selected = {
          chord: chosenChord,
          octave: 3,
          inversion: 0,
          path: fallbackPath,
          url: fallbackUrl
        };
      }

      current = {
        chord: selected.chord,
        audioUrl: selected.url,
        octave: selected.octave,
        inversion: selected.inversion
      };

      locked = false;
      pendingWrong = false;
      hintArea.style.display = "none";
      hintArea.textContent = "";
      [...opts.children].forEach(b => b.classList.remove("ok", "ng"));
      enableOptions(true);
      logSelection(selected);
      $("btnReplay").disabled = false;
      $("btnHint").disabled = false;
      $("btnReveal").disabled = false;
    }

    function endQuestion(){
      locked = true;
      enableOptions(false);
      $("btnReplay").disabled = true;
      $("btnHint").disabled = true;
      $("btnReveal").disabled = true;
    }

    async function answer(choice, btn){
      if(locked) return;

      if(choice.id === current.chord.id){
        total += 1;
        score += 1;
        winStreak += 1;
        missStreak = 0;
        scoreEl.textContent = score;
        totalEl.textContent = total;
        updateAccuracy();
        status.textContent = `正解！ 答え：${current.chord.label} (${getVoicingText(current.chord.id, current.inversion)})`;
        stopActiveSources();
        await playCorrectSfx(current.audioUrl);
        endQuestion();
      }else{
        pendingWrong = true;
        missStreak += 1;
        winStreak = 0;
        status.textContent = "不正解… 再挑戦しますか？";
        locked = true;
        enableOptions(false);
        await playIncorrectSfx();
      }
    }

    $("btnStart").onclick = async () => {
      if(pendingWrong){
        total += 1;
        totalEl.textContent = total;
        updateAccuracy();
        pendingWrong = false;
      }
      await warmupAudio();
      start();
    };

    $("btnReplay").onclick = () => {
      if(!current) return;
      playAudio(current.audioUrl);
      if(pendingWrong){
        locked = false;
        enableOptions(true);
        status.textContent = "再挑戦どうぞ";
      }
    };

    $("btnReveal").onclick = () => {
      if(!current) return;
      total += 1;
      totalEl.textContent = total;
      updateAccuracy();
      pendingWrong = false;
      status.textContent = `答え：${current.chord.label} (${getVoicingText(current.chord.id, current.inversion)})`;
      endQuestion();
    };

    $("btnHint").onclick = () => {
      if(!current) return;
      hintArea.textContent = current.chord.hint;
      hintArea.style.display = "block";
      if (current.inversion > 0){
        const rootPath = buildAudioPath(current.chord.id, 3, 0);
        playAudio(withCache(rootPath));
      }else{
        playAudio(current.audioUrl);
      }
    };

    $("btnC").onclick = () => {
      const basePath = buildAudioPath("C", 3, 0);
      playAudio(withCache(basePath));
    };

    function applyToggle(btn, statEl, isOn){
      btn.classList.toggle("on", isOn);
      if(statEl){
        statEl.textContent = isOn ? "ON" : "OFF";
      }
    }

    function bindBlockControls(blockKey){
      const activeBtn = $(`${blockKey}_activeBtn`);
      const activeStat = $(`${blockKey}_activeStat`);
      const invBtn = $(`${blockKey}_invBtn`);
      const invStat = $(`${blockKey}_invStat`);
      const octMinusBtn = $(`${blockKey}_octMinus`);
      const octPlusBtn = $(`${blockKey}_octPlus`);

      applyToggle(activeBtn, activeStat, STATE[blockKey].active);
      applyToggle(invBtn, invStat, STATE[blockKey].inversion);
      applyToggle(octMinusBtn, null, STATE[blockKey].octMinus);
      applyToggle(octPlusBtn, null, STATE[blockKey].octPlus);

      activeBtn.onclick = () => {
        STATE[blockKey].active = !STATE[blockKey].active;
        applyToggle(activeBtn, activeStat, STATE[blockKey].active);
        buildOptions();
        status.textContent = "セット変更しました";
        status.classList.remove("warn");
      };

      invBtn.onclick = () => {
        STATE[blockKey].inversion = !STATE[blockKey].inversion;
        applyToggle(invBtn, invStat, STATE[blockKey].inversion);
      };

      octMinusBtn.onclick = () => {
        STATE[blockKey].octMinus = !STATE[blockKey].octMinus;
        applyToggle(octMinusBtn, null, STATE[blockKey].octMinus);
      };

      octPlusBtn.onclick = () => {
        STATE[blockKey].octPlus = !STATE[blockKey].octPlus;
        applyToggle(octPlusBtn, null, STATE[blockKey].octPlus);
      };
    }

    loadSfxOption();
    loadSfxLists();
    ORDER.forEach(bindBlockControls);
    syncSfxOption();
    sfxToggleBtn.addEventListener("click", () => {
      sfxEnhanced = !sfxEnhanced;
      saveSfxOption();
      syncSfxOption();
    });
    buildOptions();
  })();
  </script>
</body>
</html>
