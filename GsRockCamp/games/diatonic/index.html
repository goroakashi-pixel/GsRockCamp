<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Diatonic Chord Quiz ver1.2.10</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --primary:#2563eb;
      --primary-weak:#dbeafe;
      --danger:#dc2626;
      --ok:#16a34a;
      --disabled:#e5e7eb;
      --disabled-ink:#9ca3af;
      --shadow:0 8px 18px rgba(17,24,39,0.06);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
      color:var(--ink);
      background:var(--bg);
    }
    .wrap{
      max-width:560px;
      margin:0 auto;
      padding:18px 14px 28px;
    }
    header{
      margin-bottom:10px;
    }
    .titleRow{
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:28px;
      letter-spacing:0.2px;
    }
    .ver{
      font-size:14px;
      color:var(--muted);
      font-weight:600;
    }
    .patchNote{
      margin:10px 0 12px;
      padding:10px 12px;
      background:#ffffff;
      border:1px solid var(--line);
      border-radius:14px;
      box-shadow: var(--shadow);
    }
    .patchNote h2{
      margin:0 0 6px;
      font-size:13px;
      color:var(--muted);
      font-weight:700;
    }
    .patchNote ul{
      margin:0;
      padding-left:18px;
      color:#374151;
      font-size:13px;
      line-height:1.35;
    }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:14px;
      margin:12px 0;
    }

    .blockTitle{
      font-weight:800;
      font-size:16px;
      margin:2px 0 10px;
    }
    .blockInner{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fbfbff;
    }

    .optRow{
      display:grid;
      grid-template-columns: 84px 1fr;
      gap:10px;
      align-items:center;
      margin:10px 0;
    }
    .optLabel{
      font-size:13px;
      color:var(--muted);
      font-weight:800;
      text-align:left;
    }

    .btnRow{
      display:grid;
      grid-template-columns: 1fr 62px 62px;
      gap:10px;
      align-items:center;
    }

    .btn{
      width:100%;
      border-radius:14px;
      padding:12px 12px;
      font-weight:900;
      border:2px solid var(--line);
      background:#fff;
      color:var(--ink);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.small{
      padding:10px 8px;
      font-size:13px;
      border-radius:999px;
      font-weight:900;
    }
    .btn.on{
      border-color:var(--primary);
      box-shadow:0 0 0 3px rgba(37,99,235,0.12) inset;
    }
    .btn.off{
      border-color:var(--line);
    }
    .btn.disabled{
      background: #f3f4f6;
      color: var(--disabled-ink);
      border-color: var(--disabled);
      cursor:not-allowed;
      box-shadow:none;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    .bigBtn{
      padding:16px 14px;
      font-size:18px;
      border-radius:16px;
    }
    .bigBtn.primary{
      background:var(--primary);
      border-color:var(--primary);
      color:#fff;
    }
    .bigBtn.primary:active{ transform: translateY(1px); }
    .bigBtn.ghost{
      background:#fff;
      border-color:var(--line);
      color:var(--ink);
    }

    .miniRow{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      margin-top:10px;
    }
    .status{
      margin-top:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      font-weight:800;
    }
    .status.ok{ border-color:#bbf7d0; background:#f0fdf4; }
    .status.ng{ border-color:#fecaca; background:#fef2f2; }
    .status.info{ border-color:#dbeafe; background:#eff6ff; }

    .scoreRow{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted);
      font-weight:800;
      font-size:13px;
    }

    .choicesTitle{
      font-weight:900;
      margin:14px 0 10px;
      font-size:16px;
    }
    .choices{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .choiceBtn{
      padding:16px 12px;
      border-radius:16px;
      border:2px solid var(--line);
      background:#fff;
      font-weight:1000;
      font-size:18px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .choiceBtn:active{ transform: translateY(1px); }
    .choiceBtn.disabled{
      background:#f3f4f6;
      color: var(--disabled-ink);
      border-color: var(--disabled);
      cursor:not-allowed;
      transform:none;
    }

    .footerLink{
      display:block;
      margin-top:18px;
      text-align:center;
      color:var(--muted);
      font-weight:800;
      text-decoration:none;
      padding:12px 0 6px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="titleRow">
        <h1>Diatonic Chord Quiz</h1>
        <div class="ver" id="verLabel">ver1.2.10</div>
      </div>

      <div class="patchNote">
        <h2>開発中の仕様確認（主な修正点）</h2>
        <ul>
          <li>起動時：①Easyのみアクティブ（他はOFF）</li>
          <li>不正解後：回答ボタンを一時ロック（「再挑戦」を押すまで回答不可）</li>
          <li>正解/不正解時：指定フォルダのMP3をランダム再生（correct / incorrect）</li>
          <li>「もう一回」：出題中は聴き直し、不正解直後は「再挑戦」に表示切替</li>
        </ul>
      </div>
    </header>

    <!-- ① EASY -->
    <section class="card">
      <div class="blockTitle">① Easy：基本ダイアトニック（3和音）</div>
      <div class="blockInner">
        <div class="optRow">
          <div class="optLabel">アクティブ</div>
          <div class="btnRow">
            <button class="btn" id="easyActiveBtn">OFF</button>
            <button class="btn small" id="easyActOctDownBtn">Oct-</button>
            <button class="btn small" id="easyActOctUpBtn">Oct+</button>
          </div>
        </div>

        <div class="optRow">
          <div class="optLabel">転回形</div>
          <div class="btnRow">
            <button class="btn" id="easyInvBtn">OFF</button>
            <button class="btn small" id="easyInvOctDownBtn">Oct-</button>
            <button class="btn small" id="easyInvOctUpBtn">Oct+</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ② NORMAL -->
    <section class="card">
      <div class="blockTitle">② Normal：ダイアトニック4和音（7th系）</div>
      <div class="blockInner">
        <div class="optRow">
          <div class="optLabel">アクティブ</div>
          <div class="btnRow">
            <button class="btn" id="normalActiveBtn">OFF</button>
            <button class="btn small" id="normalActOctDownBtn">Oct-</button>
            <button class="btn small" id="normalActOctUpBtn">Oct+</button>
          </div>
        </div>

        <div class="optRow">
          <div class="optLabel">転回形</div>
          <div class="btnRow">
            <button class="btn" id="normalInvBtn">OFF</button>
            <button class="btn small" id="normalInvOctDownBtn">Oct-</button>
            <button class="btn small" id="normalInvOctUpBtn">Oct+</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ③ PLUS -->
    <section class="card">
      <div class="blockTitle">③ Plus：セカンダリー系</div>
      <div class="blockInner">
        <div class="optRow">
          <div class="optLabel">アクティブ</div>
          <div class="btnRow">
            <button class="btn" id="plusActiveBtn">OFF</button>
            <button class="btn small" id="plusActOctDownBtn">Oct-</button>
            <button class="btn small" id="plusActOctUpBtn">Oct+</button>
          </div>
        </div>

        <div class="optRow">
          <div class="optLabel">転回形</div>
          <div class="btnRow">
            <button class="btn" id="plusInvBtn">OFF</button>
            <button class="btn small" id="plusInvOctDownBtn">Oct-</button>
            <button class="btn small" id="plusInvOctUpBtn">Oct+</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ④ HARD -->
    <section class="card">
      <div class="blockTitle">④ Hard：その他高度な代理</div>
      <div class="blockInner">
        <div class="optRow">
          <div class="optLabel">アクティブ</div>
          <div class="btnRow">
            <button class="btn" id="hardActiveBtn">OFF</button>
            <button class="btn small" id="hardActOctDownBtn">Oct-</button>
            <button class="btn small" id="hardActOctUpBtn">Oct+</button>
          </div>
        </div>

        <div class="optRow">
          <div class="optLabel">転回形</div>
          <div class="btnRow">
            <button class="btn" id="hardInvBtn">OFF</button>
            <button class="btn small" id="hardInvOctDownBtn">Oct-</button>
            <button class="btn small" id="hardInvOctUpBtn">Oct+</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Buttons -->
    <section class="card">
      <div class="controls">
        <button class="btn bigBtn primary" id="btnAsk">出題</button>
        <button class="btn bigBtn ghost" id="btnAgain" disabled>もう一回</button>
      </div>

      <div class="miniRow">
        <button class="btn" id="btnReveal" disabled>答え</button>
        <button class="btn" id="btnHint" disabled>ヒント</button>
        <button class="btn" id="btnRefC">C（基準音）</button>
      </div>

      <div id="statusBox" class="status info">待機中</div>

      <div class="scoreRow">
        <div id="scoreText">スコア 0/0</div>
        <div id="rateText">正答率 --%</div>
      </div>
    </section>

    <!-- Choices -->
    <section class="card">
      <div class="choicesTitle">答え</div>
      <div id="choices" class="choices"></div>
    </section>

    <a class="footerLink" href="../../index.html">← ポータルに戻る</a>
  </div>

<script>
(() => {
  "use strict";

  // =========================
  // Version / Cache buster
  // =========================
  const VER = "1.2.10";

  // =========================
  // Paths
  // =========================
  // このHTMLは: GsRockCamp/games/diatonic/ に置く前提
  // 音源は:    GsRockCamp/games/diatonic/audio/ に置く前提
  const AUDIO_BASE = "./audio/";
  const SFX_CORRECT_BASE   = "../../GsRockCamp/assets/sound/correct/";
  const SFX_INCORRECT_BASE = "../../GsRockCamp/assets/sound/incorrect/";

  // GitHub API（フォルダ内MP3を自動取得）
  const GH_OWNER = "goroakashi-pixel";
  const GH_REPO  = "GoRockCamp";
  const GH_SFX_CORRECT_API   = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/GsRockCamp/assets/sound/correct`;
  const GH_SFX_INCORRECT_API = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/GsRockCamp/assets/sound/incorrect`;

  // =========================
  // Data: chord sets
  // =========================
  // 表示順：C→…→B（基本はこの順を崩さない）
  const EASY_IDS   = ["C","Dm","Em","F","G","Am","Bm-5"];
  const NORMAL_IDS = ["CM7","Dm7","Em7","FM7","G7","Am7","Bm7-5"];

  // ③④は拡張枠（ここは後で増やしてOK）
  const PLUS_IDS = ["A7","D7","E7","Db7"];
  const HARD_IDS = ["Bb","Ab","Fm","Gm","F#dim","G#dim7"];

  // 転回形の最大数（triad: 2, 7th: 3, その他: 0想定）
  const INV_MAX = {
    "C":2,"Dm":2,"Em":2,"F":2,"G":2,"Am":2,"Bm-5":2,
    "CM7":3,"Dm7":3,"Em7":3,"FM7":3,"G7":3,"Am7":3,"Bm7-5":3
  };

  // 表示用のボイシング（簡易：根音/転回形で回転）
  // triad: root-3-5-3 / 1st: 3-5-root-5 / 2nd: 5-root-3-root
  // 7th: root-3-5-7 / 1st: 3-5-7-root / 2nd: 5-7-root-3 / 3rd: 7-root-3-5
  const CHORD_NOTES = {
    "C":   ["C-E-G-E","E-G-C-G","G-C-E-C"],
    "Dm":  ["D-F-A-F","F-A-D-A","A-D-F-D"],
    "Em":  ["E-G-B-G","G-B-E-B","B-E-G-E"],
    "F":   ["F-A-C-A","A-C-F-C","C-F-A-F"],
    "G":   ["G-B-D-B","B-D-G-D","D-G-B-G"],
    "Am":  ["A-C-E-C","C-E-A-E","E-A-C-A"],
    "Bm-5":["B-D-F-D","D-F-B-F","F-B-D-B"],

    "CM7":   ["C-E-G-B","E-G-B-C","G-B-C-E","B-C-E-G"],
    "Dm7":   ["D-F-A-C","F-A-C-D","A-C-D-F","C-D-F-A"],
    "Em7":   ["E-G-B-D","G-B-D-E","B-D-E-G","D-E-G-B"],
    "FM7":   ["F-A-C-E","A-C-E-F","C-E-F-A","E-F-A-C"],
    "G7":    ["G-B-D-F","B-D-F-G","D-F-G-B","F-G-B-D"],
    "Am7":   ["A-C-E-G","C-E-G-A","E-G-A-C","G-A-C-E"],
    "Bm7-5": ["B-D-F-A","D-F-A-B","F-A-B-D","A-B-D-F"],

    "A7":  ["A-C#-E-G"],
    "D7":  ["D-F#-A-C"],
    "E7":  ["E-G#-B-D"],
    "Db7": ["Db-F-Ab-Cb"],
    "Bb":  ["Bb-D-F-D"],
    "Ab":  ["Ab-C-Eb-C"],
    "Fm":  ["F-Ab-C-Ab"],
    "Gm":  ["G-Bb-D-Bb"],
    "F#dim":["F#-A-C-A"],
    "G#dim7":["G#-B-D-F"]
  };

  // =========================
  // State
  // =========================
  const state = {
    total: 0,
    score: 0,

    // current question
    asked: false,
    lockedAfterWrong: false, // 不正解後の回答ロック
    current: null, // { id, fileUrl, invLabel, notesLabel, srcLabel }

    // blocks
    blocks: {
      easy:   { active:true, inv:false, actOct2:false, actOct4:false, invOct2:false, invOct4:false },
      normal: { active:false, inv:false, actOct2:false, actOct4:false, invOct2:false, invOct4:false },
      plus:   { active:false, inv:false, actOct2:false, actOct4:false, invOct2:false, invOct4:false },
      hard:   { active:false, inv:false, actOct2:false, actOct4:false, invOct2:false, invOct4:false }
    },

    // sfx caches
    sfxCorrect: null,   // array of filenames
    sfxIncorrect: null  // array of filenames
  };

  // =========================
  // DOM
  // =========================
  const el = {
    verLabel: document.getElementById("verLabel"),

    btnAsk: document.getElementById("btnAsk"),
    btnAgain: document.getElementById("btnAgain"),
    btnReveal: document.getElementById("btnReveal"),
    btnHint: document.getElementById("btnHint"),
    btnRefC: document.getElementById("btnRefC"),

    statusBox: document.getElementById("statusBox"),
    scoreText: document.getElementById("scoreText"),
    rateText: document.getElementById("rateText"),

    choices: document.getElementById("choices"),

    // buttons: easy
    easyActiveBtn: document.getElementById("easyActiveBtn"),
    easyInvBtn: document.getElementById("easyInvBtn"),
    easyActOctDownBtn: document.getElementById("easyActOctDownBtn"),
    easyActOctUpBtn: document.getElementById("easyActOctUpBtn"),
    easyInvOctDownBtn: document.getElementById("easyInvOctDownBtn"),
    easyInvOctUpBtn: document.getElementById("easyInvOctUpBtn"),

    // normal
    normalActiveBtn: document.getElementById("normalActiveBtn"),
    normalInvBtn: document.getElementById("normalInvBtn"),
    normalActOctDownBtn: document.getElementById("normalActOctDownBtn"),
    normalActOctUpBtn: document.getElementById("normalActOctUpBtn"),
    normalInvOctDownBtn: document.getElementById("normalInvOctDownBtn"),
    normalInvOctUpBtn: document.getElementById("normalInvOctUpBtn"),

    // plus
    plusActiveBtn: document.getElementById("plusActiveBtn"),
    plusInvBtn: document.getElementById("plusInvBtn"),
    plusActOctDownBtn: document.getElementById("plusActOctDownBtn"),
    plusActOctUpBtn: document.getElementById("plusActOctUpBtn"),
    plusInvOctDownBtn: document.getElementById("plusInvOctDownBtn"),
    plusInvOctUpBtn: document.getElementById("plusInvOctUpBtn"),

    // hard
    hardActiveBtn: document.getElementById("hardActiveBtn"),
    hardInvBtn: document.getElementById("hardInvBtn"),
    hardActOctDownBtn: document.getElementById("hardActOctDownBtn"),
    hardActOctUpBtn: document.getElementById("hardActOctUpBtn"),
    hardInvOctDownBtn: document.getElementById("hardInvOctDownBtn"),
    hardInvOctUpBtn: document.getElementById("hardInvOctUpBtn"),
  };

  el.verLabel.textContent = `ver${VER}`;

  // =========================
  // Helpers
  // =========================
  function setStatus(text, mode="info"){
    el.statusBox.textContent = text;
    el.statusBox.classList.remove("ok","ng","info");
    el.statusBox.classList.add(mode);
  }

  function updateScore(){
    el.scoreText.textContent = `スコア ${state.score}/${state.total}`;
    if(state.total === 0){
      el.rateText.textContent = "正答率 --%";
      return;
    }
    const rate = Math.round((state.score / state.total) * 1000) / 10; // x.x%
    el.rateText.textContent = `正答率 ${rate}%`;
  }

  function randPick(arr){
    if(!arr || arr.length===0) return null;
    return arr[Math.floor(Math.random()*arr.length)];
  }

  function buildOctCandidates(include2, include4){
    const o = [3];
    if(include2) o.push(2);
    if(include4) o.push(4);
    return o;
  }

  function invLabel(invIdx, is7th){
    if(invIdx === 0) return "ルート";
    if(!is7th){
      return invIdx === 1 ? "第1転回形" : "第2転回形";
    }
    if(invIdx === 1) return "第1転回形";
    if(invIdx === 2) return "第2転回形";
    return "第3転回形";
  }

  function is7thChord(id){
    return id.endsWith("7") || id.endsWith("M7") || id.endsWith("m7-5") || id.endsWith("m7") || id.endsWith("M7") || id.endsWith("7-5");
  }

  // =========================
  // Audio (question)
  // =========================
  let currentAudio = null;

  function stopCurrentAudio(){
    try{
      if(currentAudio){
        currentAudio.pause();
        currentAudio.currentTime = 0;
      }
    }catch(_){}
  }

  function playUrl(url){
    stopCurrentAudio();
    currentAudio = new Audio(url);
    currentAudio.preload = "auto";
    return currentAudio.play().catch((e)=>{
      // iOS/Chrome等でブロックされるケースはあるが、今回はユーザー操作起点なので通常OK
      console.warn("Audio play failed:", e);
    });
  }

  // =========================
  // SFX listing via GitHub API
  // =========================
  async function fetchSfxList(kind){
    // kind: "correct" | "incorrect"
    if(kind === "correct" && Array.isArray(state.sfxCorrect)) return state.sfxCorrect;
    if(kind === "incorrect" && Array.isArray(state.sfxIncorrect)) return state.sfxIncorrect;

    const apiUrl = (kind === "correct") ? GH_SFX_CORRECT_API : GH_SFX_INCORRECT_API;

    try{
      const r = await fetch(apiUrl, { cache: "no-store" });
      if(!r.ok) throw new Error(`GitHub API status ${r.status}`);
      const j = await r.json();
      const names = (Array.isArray(j) ? j : [])
        .filter(x => x && x.type === "file" && typeof x.name === "string" && x.name.toLowerCase().endsWith(".mp3"))
        .map(x => x.name)
        .sort((a,b)=>a.localeCompare(b));

      if(kind === "correct") state.sfxCorrect = names;
      else state.sfxIncorrect = names;

      return names;
    }catch(e){
      console.warn("fetchSfxList failed:", e);
      if(kind === "correct") state.sfxCorrect = [];
      else state.sfxIncorrect = [];
      return [];
    }
  }

  async function playSfx(kind){
    const list = await fetchSfxList(kind);
    const pick = randPick(list);
    if(!pick){
      // 何も鳴らさない（仕様：鳴らない問題を隠さず、Networkにも出ないので気づける）
      console.warn(`SFX list empty: ${kind}`);
      return;
    }
    const base = (kind === "correct") ? SFX_CORRECT_BASE : SFX_INCORRECT_BASE;
    const url = `${base}${encodeURIComponent(pick)}?v=${encodeURIComponent(VER)}`;

    // 効果音は別Audioで（出題音と分離）
    const a = new Audio(url);
    a.preload = "auto";
    a.play().catch(e => console.warn("SFX play failed:", e));
  }

  // =========================
  // Build pool & choices
  // =========================
  function activeIds(){
    const ids = [];

    if(state.blocks.easy.active)   ids.push(...EASY_IDS);
    if(state.blocks.normal.active) ids.push(...NORMAL_IDS);
    if(state.blocks.plus.active)   ids.push(...PLUS_IDS);
    if(state.blocks.hard.active)   ids.push(...HARD_IDS);

    // 重複除去しつつ順序維持
    const seen = new Set();
    return ids.filter(x => (seen.has(x) ? false : (seen.add(x), true)));
  }

  function orderedChoices(){
    // 大枠の順序（C→Bを守りつつカテゴリ順で並べる）
    const act = activeIds();
    const order = [...EASY_IDS, ...NORMAL_IDS, ...PLUS_IDS, ...HARD_IDS];
    const set = new Set(act);
    return order.filter(x => set.has(x));
  }

  function rebuildChoices(){
    el.choices.innerHTML = "";
    const list = orderedChoices();

    list.forEach(id => {
      const b = document.createElement("button");
      b.className = "choiceBtn";
      b.textContent = id;
      b.addEventListener("click", () => onAnswer(id));
      el.choices.appendChild(b);
    });

    syncAnswerButtons();
  }

  function setChoicesEnabled(enabled){
    const btns = el.choices.querySelectorAll("button.choiceBtn");
    btns.forEach(b => {
      if(enabled){
        b.classList.remove("disabled");
        b.disabled = false;
      }else{
        b.classList.add("disabled");
        b.disabled = true;
      }
    });
  }

  function syncAnswerButtons(){
    if(!state.asked){
      setChoicesEnabled(false);
      return;
    }
    // 不正解ロック中は回答不可
    if(state.lockedAfterWrong){
      setChoicesEnabled(false);
      return;
    }
    setChoicesEnabled(true);
  }

  // =========================
  // Question generation
  // =========================
  function buildQuestionCandidates(){
    const candidates = [];

    const act = activeIds();
    act.forEach(id => {
      // どのブロック由来かを判定（oct/invはブロック別設定）
      // 1つのidが複数ブロックに跨るケースは想定薄なので、最初に見つかったブロックで扱う
      let blockKey = null;
      if(state.blocks.easy.active && EASY_IDS.includes(id)) blockKey = "easy";
      else if(state.blocks.normal.active && NORMAL_IDS.includes(id)) blockKey = "normal";
      else if(state.blocks.plus.active && PLUS_IDS.includes(id)) blockKey = "plus";
      else if(state.blocks.hard.active && HARD_IDS.includes(id)) blockKey = "hard";

      if(!blockKey) return;

      candidates.push({ id, blockKey });
    });

    return candidates;
  }

  function makeFileName(id, invIdx, octave){
    // invIdx: 0=root, 1..n
    if(invIdx === 0){
      return `${id}_${octave}.mp3`;
    }
    return `${id}_inv${invIdx}_${octave}.mp3`;
  }

  function makeRootFileName(id, octave){
    return `${id}_${octave}.mp3`;
  }

  async function playWithFallback(primaryUrl, fallbacks){
    // primaryUrl -> try; if error, try fallbacks (in order)
    return new Promise((resolve) => {
      stopCurrentAudio();
      const a = new Audio(primaryUrl);
      currentAudio = a;
      a.preload = "auto";

      let tried = 0;
      const all = [primaryUrl, ...fallbacks];

      const tryNext = () => {
        if(tried >= all.length){
          console.warn("All audio fallbacks failed");
          resolve(false);
          return;
        }
        const url = all[tried++];
        stopCurrentAudio();
        const x = new Audio(url);
        currentAudio = x;
        x.preload = "auto";

        x.addEventListener("error", () => tryNext(), { once:true });
        x.play().then(()=>resolve(true)).catch(()=>tryNext());
      };

      a.addEventListener("error", () => tryNext(), { once:true });
      a.play().then(()=>resolve(true)).catch(()=>tryNext());
    });
  }

  async function askQuestion(){
    const pool = buildQuestionCandidates();
    if(pool.length === 0){
      setStatus("出題できません（アクティブが0）", "ng");
      state.asked = false;
      state.current = null;
      el.btnAgain.disabled = true;
      el.btnReveal.disabled = true;
      el.btnHint.disabled = true;
      syncAnswerButtons();
      return;
    }

    // 新規出題
    state.asked = true;
    state.lockedAfterWrong = false;

    // pick chord
    const picked = randPick(pool);
    const id = picked.id;
    const blockKey = picked.blockKey;
    const b = state.blocks[blockKey];

    // decide whether we use inversion, and which octave flags to apply
    const useInv = !!b.inv;
    const is7 = !!is7thChord(id);
    const invMax = INV_MAX[id] || 0;

    // choose "variant": root only, or root+inversions mix
    let invIdx = 0;
    if(useInv && invMax > 0){
      const invCandidates = [0];
      for(let k=1;k<=invMax;k++) invCandidates.push(k);
      invIdx = randPick(invCandidates);
    }

    // choose octave pool based on which row this variant belongs to
    // invIdx=0 -> active row oct flags, invIdx>0 -> inversion row oct flags
    const octCandidates = (invIdx === 0)
      ? buildOctCandidates(b.actOct2, b.actOct4)
      : buildOctCandidates(b.invOct2, b.invOct4);

    const octave = randPick(octCandidates);

    // file url
    const fileName = makeFileName(id, invIdx, octave);
    const fileUrl  = `${AUDIO_BASE}${encodeURIComponent(fileName)}?v=${encodeURIComponent(VER)}`;

    // fallback: if inversion missing -> root same octave -> root _3
    const fallbackUrls = [];
    if(invIdx !== 0){
      fallbackUrls.push(`${AUDIO_BASE}${encodeURIComponent(makeRootFileName(id, octave))}?v=${encodeURIComponent(VER)}`);
    }
    if(octave !== 3){
      // prefer same inv but octave 3
      fallbackUrls.push(`${AUDIO_BASE}${encodeURIComponent(makeFileName(id, invIdx, 3))}?v=${encodeURIComponent(VER)}`);
      if(invIdx !== 0){
        fallbackUrls.push(`${AUDIO_BASE}${encodeURIComponent(makeRootFileName(id, 3))}?v=${encodeURIComponent(VER)}`);
      }
    }

    // Display label
    const invText = invLabel(invIdx, is7);
    const notesArr = CHORD_NOTES[id] || [];
    const notesText = (invIdx <= notesArr.length-1) ? notesArr[invIdx] : (notesArr[0] || "");
    const fullLabel = `${id}（${notesText} ${invText}）`;

    state.current = {
      id,
      blockKey,
      invIdx,
      octave,
      fileUrl,
      invText,
      notesText,
      fullLabel
    };

    // UI
    el.btnAgain.disabled = false;
    el.btnReveal.disabled = false;
    el.btnHint.disabled = false;
    el.btnAgain.textContent = "もう一回";
    setStatus("出題中：答えを選んでください", "info");
    rebuildChoices();
    syncAnswerButtons();

    // play audio (with fallback)
    await playWithFallback(fileUrl, fallbackUrls);
  }

  // =========================
  // Answering logic
  // =========================
  async function onAnswer(answerId){
    if(!state.asked || !state.current){
      return;
    }
    // 不正解後ロック中
    if(state.lockedAfterWrong){
      setStatus("再挑戦をクリックしてください。", "ng");
      return;
    }

    // 採点は「回答クリック時点で確定」
    state.total += 1;
    const correct = (answerId === state.current.id);
    if(correct) state.score += 1;
    updateScore();

    if(correct){
      setStatus(`正解！ ${state.current.fullLabel}`, "ok");
      await playSfx("correct");
      // 正解後は次の出題待ち（回答はロックしない：そのまま次へ行ってもOKだが、誤操作防止でロックする）
      // ここは運用上の事故防止として、正解後も回答はロック（次の出題まで触れない）
      state.lockedAfterWrong = true;
      el.btnAgain.textContent = "もう一回";
      setChoicesEnabled(false);
    }else{
      setStatus(`不正解（正解：${state.current.fullLabel}）`, "ng");
      await playSfx("incorrect");
      // 不正解後は回答ロック＆「再挑戦」に切替
      state.lockedAfterWrong = true;
      el.btnAgain.textContent = "再挑戦";
      setChoicesEnabled(false);
    }
  }

  async function onAgain(){
    if(!state.asked || !state.current) return;

    // 不正解後は「再挑戦」＝同一ファイル再生＋再回答状態へ
    if(state.lockedAfterWrong && el.btnAgain.textContent === "再挑戦"){
      setStatus("再回答中：答えを選んでください", "info");
      state.lockedAfterWrong = false;
      el.btnAgain.textContent = "もう一回";
      syncAnswerButtons();
      await playWithFallback(state.current.fileUrl, []);
      return;
    }

    // 通常時（出題中）＝同一ファイル聴き直し
    await playWithFallback(state.current.fileUrl, []);
  }

  function onReveal(){
    if(!state.asked || !state.current) return;
    setStatus(`答え：${state.current.fullLabel}`, "info");
  }

  function onHint(){
    if(!state.asked || !state.current) return;
    // ヒント：ブロック名だけ
    const map = { easy:"①Easy", normal:"②Normal", plus:"③Plus", hard:"④Hard" };
    setStatus(`ヒント：${map[state.current.blockKey]}`, "info");
  }

  async function onRefC(){
    // 基準音：C_3固定（存在前提）
    const url = `${AUDIO_BASE}C_3.mp3?v=${encodeURIComponent(VER)}`;
    await playWithFallback(url, []);
  }

  // =========================
  // Block UI wiring
  // =========================
  function setBtnOnOff(btn, isOn){
    btn.textContent = isOn ? "ON" : "OFF";
    btn.classList.toggle("on", isOn);
    btn.classList.toggle("off", !isOn);
  }

  function setOctBtn(btn, isOn){
    btn.classList.toggle("on", isOn);
    btn.classList.toggle("off", !isOn);
  }

  function setDisabled(btn, disabled){
    btn.disabled = !!disabled;
    btn.classList.toggle("disabled", !!disabled);
  }

  function resetToIdleBecauseSettingsChanged(){
    stopCurrentAudio();
    state.asked = false;
    state.current = null;
    state.lockedAfterWrong = false;
    el.btnAgain.disabled = true;
    el.btnReveal.disabled = true;
    el.btnHint.disabled = true;
    el.btnAgain.textContent = "もう一回";
    setStatus("待機中", "info");
    rebuildChoices();
  }

  function syncBlockUI(){
    // easy
    setBtnOnOff(el.easyActiveBtn, state.blocks.easy.active);
    setBtnOnOff(el.easyInvBtn, state.blocks.easy.inv);
    setOctBtn(el.easyActOctDownBtn, state.blocks.easy.actOct2);
    setOctBtn(el.easyActOctUpBtn, state.blocks.easy.actOct4);
    setOctBtn(el.easyInvOctDownBtn, state.blocks.easy.invOct2);
    setOctBtn(el.easyInvOctUpBtn, state.blocks.easy.invOct4);

    // normal
    setBtnOnOff(el.normalActiveBtn, state.blocks.normal.active);
    setBtnOnOff(el.normalInvBtn, state.blocks.normal.inv);
    setOctBtn(el.normalActOctDownBtn, state.blocks.normal.actOct2);
    setOctBtn(el.normalActOctUpBtn, state.blocks.normal.actOct4);
    setOctBtn(el.normalInvOctDownBtn, state.blocks.normal.invOct2);
    setOctBtn(el.normalInvOctUpBtn, state.blocks.normal.invOct4);

    // plus
    setBtnOnOff(el.plusActiveBtn, state.blocks.plus.active);
    setBtnOnOff(el.plusInvBtn, state.blocks.plus.inv);
    setOctBtn(el.plusActOctDownBtn, state.blocks.plus.actOct2);
    setOctBtn(el.plusActOctUpBtn, state.blocks.plus.actOct4);
    setOctBtn(el.plusInvOctDownBtn, state.blocks.plus.invOct2);
    setOctBtn(el.plusInvOctUpBtn, state.blocks.plus.invOct4);

    // hard
    setBtnOnOff(el.hardActiveBtn, state.blocks.hard.active);
    setBtnOnOff(el.hardInvBtn, state.blocks.hard.inv);
    setOctBtn(el.hardActOctDownBtn, state.blocks.hard.actOct2);
    setOctBtn(el.hardActOctUpBtn, state.blocks.hard.actOct4);
    setOctBtn(el.hardInvOctDownBtn, state.blocks.hard.invOct2);
    setOctBtn(el.hardInvOctUpBtn, state.blocks.hard.invOct4);

    // disabled rules:
    // ブロック非アクティブなら、そのブロック内の転回形＆Octは全部disabled
    // 転回形OFFなら、転回形側Octはdisabled
    const keys = ["easy","normal","plus","hard"];
    keys.forEach(k => {
      const b = state.blocks[k];

      const map = {
        easy:   [el.easyInvBtn, el.easyActOctDownBtn, el.easyActOctUpBtn, el.easyInvOctDownBtn, el.easyInvOctUpBtn],
        normal: [el.normalInvBtn, el.normalActOctDownBtn, el.normalActOctUpBtn, el.normalInvOctDownBtn, el.normalInvOctUpBtn],
        plus:   [el.plusInvBtn, el.plusActOctDownBtn, el.plusActOctUpBtn, el.plusInvOctDownBtn, el.plusInvOctUpBtn],
        hard:   [el.hardInvBtn, el.hardActOctDownBtn, el.hardActOctUpBtn, el.hardInvOctDownBtn, el.hardInvOctUpBtn],
      };

      // block active off -> disable all except active button itself
      const disableAll = !b.active;
      map[k].forEach(btn => setDisabled(btn, disableAll));

      // if block active ON, inversion OFF -> disable inversion octave buttons only
      if(b.active){
        const invOctBtns = {
          easy:[el.easyInvOctDownBtn, el.easyInvOctUpBtn],
          normal:[el.normalInvOctDownBtn, el.normalInvOctUpBtn],
          plus:[el.plusInvOctDownBtn, el.plusInvOctUpBtn],
          hard:[el.hardInvOctDownBtn, el.hardInvOctUpBtn],
        };
        invOctBtns[k].forEach(btn => setDisabled(btn, !b.inv));
      }
    });

    // game side
    syncAnswerButtons();
  }

  function toggleBool(v){ return !v; }

  // Buttons wiring (settings)
  function bindToggle(btn, getRef, setRef){
    btn.addEventListener("click", () => {
      setRef(toggleBool(getRef()));
      syncBlockUI();
      resetToIdleBecauseSettingsChanged();
    });
  }

  // easy
  bindToggle(el.easyActiveBtn, () => state.blocks.easy.active, v => state.blocks.easy.active = v);
  bindToggle(el.easyInvBtn, () => state.blocks.easy.inv, v => state.blocks.easy.inv = v);
  bindToggle(el.easyActOctDownBtn, () => state.blocks.easy.actOct2, v => state.blocks.easy.actOct2 = v);
  bindToggle(el.easyActOctUpBtn, () => state.blocks.easy.actOct4, v => state.blocks.easy.actOct4 = v);
  bindToggle(el.easyInvOctDownBtn, () => state.blocks.easy.invOct2, v => state.blocks.easy.invOct2 = v);
  bindToggle(el.easyInvOctUpBtn, () => state.blocks.easy.invOct4, v => state.blocks.easy.invOct4 = v);

  // normal
  bindToggle(el.normalActiveBtn, () => state.blocks.normal.active, v => state.blocks.normal.active = v);
  bindToggle(el.normalInvBtn, () => state.blocks.normal.inv, v => state.blocks.normal.inv = v);
  bindToggle(el.normalActOctDownBtn, () => state.blocks.normal.actOct2, v => state.blocks.normal.actOct2 = v);
  bindToggle(el.normalActOctUpBtn, () => state.blocks.normal.actOct4, v => state.blocks.normal.actOct4 = v);
  bindToggle(el.normalInvOctDownBtn, () => state.blocks.normal.invOct2, v => state.blocks.normal.invOct2 = v);
  bindToggle(el.normalInvOctUpBtn, () => state.blocks.normal.invOct4, v => state.blocks.normal.invOct4 = v);

  // plus
  bindToggle(el.plusActiveBtn, () => state.blocks.plus.active, v => state.blocks.plus.active = v);
  bindToggle(el.plusInvBtn, () => state.blocks.plus.inv, v => state.blocks.plus.inv = v);
  bindToggle(el.plusActOctDownBtn, () => state.blocks.plus.actOct2, v => state.blocks.plus.actOct2 = v);
  bindToggle(el.plusActOctUpBtn, () => state.blocks.plus.actOct4, v => state.blocks.plus.actOct4 = v);
  bindToggle(el.plusInvOctDownBtn, () => state.blocks.plus.invOct2, v => state.blocks.plus.invOct2 = v);
  bindToggle(el.plusInvOctUpBtn, () => state.blocks.plus.invOct4, v => state.blocks.plus.invOct4 = v);

  // hard
  bindToggle(el.hardActiveBtn, () => state.blocks.hard.active, v => state.blocks.hard.active = v);
  bindToggle(el.hardInvBtn, () => state.blocks.hard.inv, v => state.blocks.hard.inv = v);
  bindToggle(el.hardActOctDownBtn, () => state.blocks.hard.actOct2, v => state.blocks.hard.actOct2 = v);
  bindToggle(el.hardActOctUpBtn, () => state.blocks.hard.actOct4, v => state.blocks.hard.actOct4 = v);
  bindToggle(el.hardInvOctDownBtn, () => state.blocks.hard.invOct2, v => state.blocks.hard.invOct2 = v);
  bindToggle(el.hardInvOctUpBtn, () => state.blocks.hard.invOct4, v => state.blocks.hard.invOct4 = v);

  // =========================
  // Main buttons
  // =========================
  el.btnAsk.addEventListener("click", () => askQuestion());
  el.btnAgain.addEventListener("click", () => onAgain());
  el.btnReveal.addEventListener("click", () => onReveal());
  el.btnHint.addEventListener("click", () => onHint());
  el.btnRefC.addEventListener("click", () => onRefC());

  // =========================
  // Init
  // =========================
  function init(){
    // 起動時：①のみアクティブ、他OFF
    state.blocks.easy.active = true;
    state.blocks.normal.active = false;
    state.blocks.plus.active = false;
    state.blocks.hard.active = false;

    // 起動時：全部OFF
    state.blocks.easy.inv = false;
    state.blocks.normal.inv = false;
    state.blocks.plus.inv = false;
    state.blocks.hard.inv = false;

    // Oct混在（初期はOFF）
    ["easy","normal","plus","hard"].forEach(k=>{
      state.blocks[k].actOct2 = false;
      state.blocks[k].actOct4 = false;
      state.blocks[k].invOct2 = false;
      state.blocks[k].invOct4 = false;
    });

    updateScore();
    syncBlockUI();
    resetToIdleBecauseSettingsChanged();

    // 先にSFX一覧を温める（失敗してもゲーム自体は動く）
    fetchSfxList("correct");
    fetchSfxList("incorrect");
  }

  init();
})();
</script>

</body>
</html>
