<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Diatonic Chord Quiz</title>

  <style>
    :root{
      --text:#111;
      --muted:#666;
      --line:#ddd;
      --bg:#fff;
      --card:#fff;
      --blue:#1d4ed8;
      --warn:#b91c1c;

      --btn-bg:#fff;
      --btn-on-border: 2px solid var(--blue);
      --btn-off-border: 1px solid var(--line);
      --btn-radius: 16px;

      --oct-font: 14px;
      --main-font: 16px;
      --title-font: 22px;

      --tap-min-h: 44px;
    }

    body{
      font-family:-apple-system, system-ui, "Segoe UI", sans-serif;
      margin:16px;
      color:var(--text);
      background:var(--bg);
      padding-bottom:140px;
    }

    .wrap{ max-width:820px; margin:0 auto; }

    h1{
      font-size:var(--title-font);
      margin:6px 0 6px;
      letter-spacing:.2px;
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .ver{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
    }

    .changelog{
      margin:0 0 12px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
    }
    .changelog-title{
      font-weight:900;
      margin:0 0 6px;
      color:var(--muted);
      font-size:12px;
    }
    .changelog ul{
      margin:0;
      padding-left:18px;
      color:#333;
      line-height:1.4;
      font-size:13px;
    }
    .changelog li{ margin:4px 0; }

    .box{
      padding:14px;
      border:1px solid var(--line);
      border-radius:14px;
      background:var(--card);
      margin-top:12px;
    }

    .block{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fafafa;
      margin-top:12px;
    }
    .block-title{
      font-weight:900;
      font-size:18px;
      margin:0 0 10px;
    }

    .opt-row{
      display:grid;
      grid-template-columns: minmax(160px, 1fr) minmax(160px, 1fr);
      gap:10px;
      align-items:stretch;
      margin-top:10px;
    }

    .btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:12px 14px;
      font-size:var(--main-font);
      border-radius:var(--btn-radius);
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{ opacity:.45; }

    .btn.on{ border: var(--btn-on-border); }

    .btn small{
      font-weight:900;
      color:var(--muted);
      letter-spacing:.3px;
    }

    .oct-pair{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .oct-btn{
      width:100%;
      min-height: var(--tap-min-h);
      padding:10px 10px;
      font-size:var(--oct-font);
      border-radius:999px;
      border: var(--btn-off-border);
      background:var(--btn-bg);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .oct-btn:active{ transform: translateY(1px); }
    .oct-btn[disabled]{ opacity:.45; }
    .oct-btn.on{ border: var(--btn-on-border); }

    .btn-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }

    button.ctrl{
      padding:12px 14px;
      font-size:16px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    button.ctrl:disabled{ opacity:.45; }
    #btnStart{
      flex: 1 1 220px;
      font-size:20px;
      padding:16px 18px;
    }

    .status{ margin-top:12px; font-weight:900; }
    .status.warn{ color: var(--warn); }

    .hintArea{
      margin-top:10px;
      padding:12px;
      border:1px dashed #aaa;
      border-radius:12px;
      display:none;
      background:#fafafa;
      white-space:pre-wrap;
      line-height:1.5;
    }

    .scorebar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      font-weight:900;
    }
    .accuracy.good{ color: var(--blue); }

    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(120px,1fr));
      gap:10px;
      margin-top:10px;
    }
    .choice{
      padding:14px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    .choice:disabled{ opacity:.45; }

    .backwrap{ margin-top: 12px; text-align:center; }
    a.backbtn{
      display:inline-block;
      padding:12px 14px;
      border:1px solid var(--line);
      border-radius:14px;
      text-decoration:none;
      color:var(--text);
      background:var(--card);
      font-weight:900;
      -webkit-tap-highlight-color: transparent;
    }
    a.backbtn:active{ transform: translateY(1px); }

    @media (max-width: 420px){
      .opt-row{ grid-template-columns: 1fr; }
      .oct-pair{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>
      Diatonic Chord Quiz
      <span class="ver" id="verText">ver1.2.8</span>
    </h1>

    <div class="changelog">
      <div class="changelog-title">開発中の仕様確認（主な修正点）</div>
      <ul>
        <li>ver1.2.8：答えを押した瞬間に採点確定（正解=total+1&score+1 / 不正解=total+1）</li>
        <li>不正解直後だけ「もう一回」→「再挑戦」に変化（再挑戦は同一音再生＋再回答中へ）</li>
        <li>答えを押したら、その答えのroot _3 を再生（転回形は追従しない）</li>
        <li>起動デフォルト：①Easyのみアクティブ（②③④はOFF）</li>
        <li>選択肢の並び：C→…→B</li>
      </ul>
    </div>

    <div class="box">

      <div class="block" id="blk_easy">
        <div class="block-title">① Easy：基本ダイアトニック（3和音）</div>

        <div class="opt-row">
          <button class="btn" id="easy_activeBtn"><span>アクティブ</span><small id="easy_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="easy_rootOctMinus">Oct-</button>
            <button class="oct-btn" id="easy_rootOctPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="easy_invBtn"><span>転回形</span><small id="easy_invStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="easy_invOctMinus">Oct-</button>
            <button class="oct-btn" id="easy_invOctPlus">Oct+</button>
          </div>
        </div>
      </div>

      <div class="block" id="blk_normal">
        <div class="block-title">② Normal：ダイアトニック4和音（7th系）</div>

        <div class="opt-row">
          <button class="btn" id="normal_activeBtn"><span>アクティブ</span><small id="normal_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="normal_rootOctMinus">Oct-</button>
            <button class="oct-btn" id="normal_rootOctPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="normal_invBtn"><span>転回形</span><small id="normal_invStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="normal_invOctMinus">Oct-</button>
            <button class="oct-btn" id="normal_invOctPlus">Oct+</button>
          </div>
        </div>
      </div>

      <div class="block" id="blk_plus">
        <div class="block-title">③ Plus：セカンダリー系</div>

        <div class="opt-row">
          <button class="btn" id="plus_activeBtn"><span>アクティブ</span><small id="plus_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="plus_rootOctMinus">Oct-</button>
            <button class="oct-btn" id="plus_rootOctPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="plus_invBtn"><span>転回形</span><small id="plus_invStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="plus_invOctMinus">Oct-</button>
            <button class="oct-btn" id="plus_invOctPlus">Oct+</button>
          </div>
        </div>
      </div>

      <div class="block" id="blk_hard">
        <div class="block-title">④ Hard：その他高度な代理</div>

        <div class="opt-row">
          <button class="btn" id="hard_activeBtn"><span>アクティブ</span><small id="hard_activeStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="hard_rootOctMinus">Oct-</button>
            <button class="oct-btn" id="hard_rootOctPlus">Oct+</button>
          </div>
        </div>

        <div class="opt-row">
          <button class="btn" id="hard_invBtn"><span>転回形</span><small id="hard_invStat">OFF</small></button>
          <div class="oct-pair">
            <button class="oct-btn" id="hard_invOctMinus">Oct-</button>
            <button class="oct-btn" id="hard_invOctPlus">Oct+</button>
          </div>
        </div>
      </div>

      <div class="btn-row">
        <button class="ctrl" id="btnStart">出題</button>
        <button class="ctrl" id="btnReplay" disabled>もう一回</button>
        <button class="ctrl" id="btnReveal" disabled>答え</button>
        <button class="ctrl" id="btnHint" disabled>ヒント</button>
        <button class="ctrl" id="btnC">C（基準音）</button>
      </div>

      <div id="status" class="status">まだ出題していません</div>
      <div id="hintArea" class="hintArea"></div>
    </div>

    <div class="box">
      <div style="font-weight:900;">答え</div>
      <div class="grid" id="choices"></div>
    </div>

    <div class="box">
      <div class="scorebar">
        <div>スコア： <span id="score">0</span>/<span id="total">0</span></div>
        <div id="accuracy" class="accuracy">正答率 00%</div>
      </div>
    </div>

    <div class="backwrap">
      <a class="backbtn" href="../../index.html">← ポータルに戻る</a>
    </div>

    <audio id="player" preload="auto"></audio>
  </div>

  <script>
  (() => {
    const VER = "1.2.8";
    document.getElementById("verText").textContent = "ver" + VER;

    const AUDIO_DIR = "audio/";
    const CACHE_BUSTER = "?v=" + encodeURIComponent(VER);

    const BLOCKS = {
      easy:   { label: "Easy",   triad: true,  chords: ["C","Dm","Em","F","G","Am","Bm-5"] },
      normal: { label: "Normal", triad: false, chords: ["CM7","Dm7","Em7","FM7","G7","Am7","Bm7-5"] },
      plus:   { label: "Plus",   triad: false, chords: ["A7","C7","D7","Db7","E7"] },
      hard:   { label: "Hard",   triad: false, chords: ["Ab","Bb","Eb","Fm","Gm","F#dim","G#dim7"] }
    };

    const CHORD_TONES = {
      "C": ["C","E","G"],
      "Dm": ["D","F","A"],
      "Em": ["E","G","B"],
      "F": ["F","A","C"],
      "G": ["G","B","D"],
      "Am": ["A","C","E"],
      "Bm-5": ["B","D","F"],
      "F#dim": ["F#","A","C"],
      "Fm": ["F","Ab","C"],
      "Gm": ["G","Bb","D"],
      "Ab": ["Ab","C","Eb"],
      "Bb": ["Bb","D","F"],
      "Eb": ["Eb","G","Bb"],

      "C7": ["C","E","G","Bb"],
      "CM7": ["C","E","G","B"],
      "Dm7": ["D","F","A","C"],
      "Em7": ["E","G","B","D"],
      "FM7": ["F","A","C","E"],
      "G7": ["G","B","D","F"],
      "Am7": ["A","C","E","G"],
      "Bm7-5": ["B","D","F","A"],
      "A7": ["A","C#","E","G"],
      "D7": ["D","F#","A","C"],
      "Db7": ["Db","F","Ab","B"],
      "E7": ["E","G#","B","D"],
      "G#dim7": ["G#","B","D","F"]
    };

    const player = document.getElementById("player");
    const statusEl = document.getElementById("status");
    const hintArea = document.getElementById("hintArea");
    const choicesWrap = document.getElementById("choices");

    const btnStart  = document.getElementById("btnStart");
    const btnReplay = document.getElementById("btnReplay");
    const btnReveal = document.getElementById("btnReveal");
    const btnHint   = document.getElementById("btnHint");
    const btnC      = document.getElementById("btnC");

    const scoreEl = document.getElementById("score");
    const totalEl = document.getElementById("total");
    const accuracyEl = document.getElementById("accuracy");

    // phase: idle | answering | retryPrompt
    let phase = "idle";
    let current = null; // {id, file, invIdx, isInv, blockKey, oct}
    let score = 0;
    let total = 0;

    // 起動デフォルト：①のみアクティブ
    const state = {
      easy:   { active:true,  inv:false, rootOctMinus:false, rootOctPlus:false, invOctMinus:false, invOctPlus:false },
      normal: { active:false, inv:false, rootOctMinus:false, rootOctPlus:false, invOctMinus:false, invOctPlus:false },
      plus:   { active:false, inv:false, rootOctMinus:false, rootOctPlus:false, invOctMinus:false, invOctPlus:false },
      hard:   { active:false, inv:false, rootOctMinus:false, rootOctPlus:false, invOctMinus:false, invOctPlus:false },
    };

    const UI = {
      easy: {
        activeBtn: document.getElementById("easy_activeBtn"),
        activeStat: document.getElementById("easy_activeStat"),
        invBtn: document.getElementById("easy_invBtn"),
        invStat: document.getElementById("easy_invStat"),
        rootOctMinus: document.getElementById("easy_rootOctMinus"),
        rootOctPlus:  document.getElementById("easy_rootOctPlus"),
        invOctMinus:  document.getElementById("easy_invOctMinus"),
        invOctPlus:   document.getElementById("easy_invOctPlus"),
      },
      normal: {
        activeBtn: document.getElementById("normal_activeBtn"),
        activeStat: document.getElementById("normal_activeStat"),
        invBtn: document.getElementById("normal_invBtn"),
        invStat: document.getElementById("normal_invStat"),
        rootOctMinus: document.getElementById("normal_rootOctMinus"),
        rootOctPlus:  document.getElementById("normal_rootOctPlus"),
        invOctMinus:  document.getElementById("normal_invOctMinus"),
        invOctPlus:   document.getElementById("normal_invOctPlus"),
      },
      plus: {
        activeBtn: document.getElementById("plus_activeBtn"),
        activeStat: document.getElementById("plus_activeStat"),
        invBtn: document.getElementById("plus_invBtn"),
        invStat: document.getElementById("plus_invStat"),
        rootOctMinus: document.getElementById("plus_rootOctMinus"),
        rootOctPlus:  document.getElementById("plus_rootOctPlus"),
        invOctMinus:  document.getElementById("plus_invOctMinus"),
        invOctPlus:   document.getElementById("plus_invOctPlus"),
      },
      hard: {
        activeBtn: document.getElementById("hard_activeBtn"),
        activeStat: document.getElementById("hard_activeStat"),
        invBtn: document.getElementById("hard_invBtn"),
        invStat: document.getElementById("hard_invStat"),
        rootOctMinus: document.getElementById("hard_rootOctMinus"),
        rootOctPlus:  document.getElementById("hard_rootOctPlus"),
        invOctMinus:  document.getElementById("hard_invOctMinus"),
        invOctPlus:   document.getElementById("hard_invOctPlus"),
      },
    };

    function setStatus(text, warn=false){
      statusEl.textContent = text;
      statusEl.classList.toggle("warn", !!warn);
    }

    function showHint(text){
      hintArea.style.display = "block";
      hintArea.textContent = text;
    }

    function clearHint(){
      hintArea.style.display = "none";
      hintArea.textContent = "";
    }

    function updateAccuracy(){
      const acc = total === 0 ? 0 : Math.round((score / total) * 100);
      accuracyEl.textContent = "正答率 " + String(acc).padStart(2,"0") + "%";
      accuracyEl.classList.toggle("good", acc >= 80);
    }

    function syncOne(blockKey){
      const s = state[blockKey];
      const u = UI[blockKey];

      u.activeStat.textContent = s.active ? "ON" : "OFF";
      u.activeBtn.classList.toggle("on", s.active);

      u.invStat.textContent = s.inv ? "ON" : "OFF";
      u.invBtn.classList.toggle("on", s.inv);

      u.rootOctMinus.classList.toggle("on", s.rootOctMinus);
      u.rootOctPlus.classList.toggle("on", s.rootOctPlus);
      u.invOctMinus.classList.toggle("on", s.invOctMinus);
      u.invOctPlus.classList.toggle("on", s.invOctPlus);

      const enabled = !!s.active;

      u.rootOctMinus.disabled = !enabled;
      u.rootOctPlus.disabled  = !enabled;

      u.invBtn.disabled       = !enabled;

      const invEnabled = enabled && !!s.inv;
      u.invOctMinus.disabled = !invEnabled;
      u.invOctPlus.disabled  = !invEnabled;
    }

    function syncAll(){
      ["easy","normal","plus","hard"].forEach(syncOne);

      if (phase === "idle"){
        buildChoices();
      }
    }

    function setChoicesEnabled(enabled){
      const btns = Array.from(document.querySelectorAll(".choice"));
      btns.forEach(b => b.disabled = !enabled);
    }

    function setReplayLabel(){
      btnReplay.textContent = (phase === "retryPrompt") ? "再挑戦" : "もう一回";
    }

    function resetToIdle(msg){
      phase = "idle";
      current = null;

      btnStart.disabled = false;
      btnReplay.disabled = true;
      btnReveal.disabled = true;
      btnHint.disabled = true;

      setReplayLabel();
      setChoicesEnabled(false);
      clearHint();
      if (msg) setStatus(msg);
    }

    function wireBlock(blockKey){
      const u = UI[blockKey];

      u.activeBtn.addEventListener("click", () => {
        state[blockKey].active = !state[blockKey].active;
        if (!state[blockKey].active){
          state[blockKey].inv = false;
          state[blockKey].rootOctMinus = false;
          state[blockKey].rootOctPlus  = false;
          state[blockKey].invOctMinus  = false;
          state[blockKey].invOctPlus   = false;
        }
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });

      u.invBtn.addEventListener("click", () => {
        if (!state[blockKey].active) return;
        state[blockKey].inv = !state[blockKey].inv;
        if (!state[blockKey].inv){
          state[blockKey].invOctMinus = false;
          state[blockKey].invOctPlus  = false;
        }
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });

      u.rootOctMinus.addEventListener("click", () => {
        if (!state[blockKey].active) return;
        state[blockKey].rootOctMinus = !state[blockKey].rootOctMinus;
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });

      u.rootOctPlus.addEventListener("click", () => {
        if (!state[blockKey].active) return;
        state[blockKey].rootOctPlus = !state[blockKey].rootOctPlus;
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });

      u.invOctMinus.addEventListener("click", () => {
        if (!state[blockKey].active || !state[blockKey].inv) return;
        state[blockKey].invOctMinus = !state[blockKey].invOctMinus;
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });

      u.invOctPlus.addEventListener("click", () => {
        if (!state[blockKey].active || !state[blockKey].inv) return;
        state[blockKey].invOctPlus = !state[blockKey].invOctPlus;
        resetToIdle("設定を変更しました（待機）");
        syncAll();
      });
    }

    wireBlock("easy");
    wireBlock("normal");
    wireBlock("plus");
    wireBlock("hard");

    function getActiveBlocks(){
      return Object.keys(BLOCKS).filter(k => state[k].active);
    }

    function getAnswerPoolChords(){
      const act = getActiveBlocks();
      const set = new Set();
      act.forEach(bk => BLOCKS[bk].chords.forEach(c => set.add(c)));
      return Array.from(set);
    }

    function getCandidateFilesForChord(blockKey, chordId, wantInv){
      const s = state[blockKey];
      const triad = BLOCKS[blockKey].triad;

      // oct: 3は常に混在。押されていれば2/4も混在。
      const octs = [3];
      if (wantInv){
        if (s.invOctMinus) octs.push(2);
        if (s.invOctPlus)  octs.push(4);
      }else{
        if (s.rootOctMinus) octs.push(2);
        if (s.rootOctPlus)  octs.push(4);
      }

      const invMax = triad ? 2 : 3;
      const files = [];

      if (!wantInv){
        octs.forEach(oct => files.push({ file: `${chordId}_${oct}.mp3`, invIdx:0, isInv:false, oct }));
        return files;
      }

      for (let i=1; i<=invMax; i++){
        octs.forEach(oct => files.push({ file: `${chordId}_inv${i}_${oct}.mp3`, invIdx:i, isInv:true, oct }));
      }
      return files;
    }

    function buildQuestionPool(){
      const act = getActiveBlocks();
      if (act.length === 0) return [];

      const pool = [];
      act.forEach(blockKey => {
        const chords = BLOCKS[blockKey].chords;
        const useInv = !!state[blockKey].inv;

        chords.forEach(chordId => {
          getCandidateFilesForChord(blockKey, chordId, false).forEach(x => {
            pool.push({ blockKey, chordId, file:x.file, invIdx:x.invIdx, isInv:x.isInv, oct:x.oct });
          });

          if (useInv){
            getCandidateFilesForChord(blockKey, chordId, true).forEach(x => {
              pool.push({ blockKey, chordId, file:x.file, invIdx:x.invIdx, isInv:x.isInv, oct:x.oct });
            });
          }
        });
      });

      return pool;
    }

    function pickRandom(arr){
      return arr[Math.floor(Math.random() * arr.length)];
    }

    async function canPlay(url){
      try{
        const r = await fetch(url, { method:"HEAD", cache:"no-store" });
        return r.ok;
      }catch{
        return false;
      }
    }

    async function playFile(file){
      const url = AUDIO_DIR + file + CACHE_BUSTER;
      player.src = url;
      try{
        await player.play();
        return true;
      }catch{
        return false;
      }
    }

    // 出題音のフォールバック：invが無ければ root_3
    async function playWithFallback(candidate){
      const tryUrl = AUDIO_DIR + candidate.file + CACHE_BUSTER;
      const ok = await canPlay(tryUrl);
      if (ok){
        return await playFile(candidate.file);
      }

      const fallback = `${candidate.chordId}_3.mp3`;
      const fbUrl = AUDIO_DIR + fallback + CACHE_BUSTER;
      const fbOk = await canPlay(fbUrl);
      if (!fbOk) return false;

      candidate.file = fallback;
      candidate.invIdx = 0;
      candidate.isInv = false;
      candidate.oct = 3;
      return await playFile(fallback);
    }

    function invLabel(invIdx){
      if (invIdx === 0) return "ルート";
      if (invIdx === 1) return "第一転回形";
      if (invIdx === 2) return "第二転回形";
      if (invIdx === 3) return "第三転回形";
      return "";
    }

    function chordVoicingText(chordId, invIdx){
      const tones = CHORD_TONES[chordId];
      if (!tones) return chordId;

      if (tones.length === 3){
        const [R, T, F] = tones;
        if (invIdx === 0) return `${R}-${T}-${F}-${T}`;
        if (invIdx === 1) return `${T}-${F}-${R}-${T}`;
        if (invIdx === 2) return `${F}-${R}-${T}-${F}`;
        return `${R}-${T}-${F}-${T}`;
      }

      if (tones.length === 4){
        const [R, T, F, S] = tones;
        if (invIdx === 0) return `${R}-${T}-${F}-${S}`;
        if (invIdx === 1) return `${T}-${F}-${S}-${R}`;
        if (invIdx === 2) return `${F}-${S}-${R}-${T}`;
        if (invIdx === 3) return `${S}-${R}-${T}-${F}`;
        return `${R}-${T}-${F}-${S}`;
      }

      return tones.join("-");
    }

    function makeHint(chordId){
      const tones = CHORD_TONES[chordId];
      if (!tones) return "未登録";
      return `構成音：${tones.join("-")}`;
    }

    // --- 選択肢並び：C→…→B ---
    function rootFromChordId(id){
      const m = id.match(/^(Ab|Bb|Cb|Db|Eb|Fb|Gb|C#|D#|E#|F#|G#|A|B|C|D|E|F|G)/);
      return m ? m[1] : id;
    }
    const ROOT_ORDER = ["C","C#","Db","D","D#","Eb","E","E#","F","F#","Gb","G","G#","Ab","A","A#","Bb","B","Cb"];
    const ROOT_SCORE = new Map(ROOT_ORDER.map((x,i)=>[x,i]));
    function qualityRank(id){
      if (/_inv\d+/.test(id)) return 99;
      if (/dim7$/.test(id)) return 8;
      if (/m7-5$/.test(id)) return 7;
      if (/m7$/.test(id)) return 6;
      if (/M7$/.test(id)) return 5;
      if (/7$/.test(id)) return 4;
      if (/m-5$/.test(id)) return 3;
      if (/dim$/.test(id)) return 2;
      if (/m$/.test(id)) return 1;
      return 0;
    }
    function sortChordIdsCtoB(a,b){
      const ra = rootFromChordId(a);
      const rb = rootFromChordId(b);
      const sa = ROOT_SCORE.has(ra) ? ROOT_SCORE.get(ra) : 999;
      const sb = ROOT_SCORE.has(rb) ? ROOT_SCORE.get(rb) : 999;
      if (sa !== sb) return sa - sb;

      const qa = qualityRank(a);
      const qb = qualityRank(b);
      if (qa !== qb) return qa - qb;

      return a.localeCompare(b, "en");
    }

    // B案：押した答えの root_3 を鳴らす
    async function playAnswerRoot3(chordId){
      const f = `${chordId}_3.mp3`;
      const url = AUDIO_DIR + f + CACHE_BUSTER;
      const ok = await canPlay(url);
      if (!ok) return false;
      return await playFile(f);
    }

    function buildChoices(){
      choicesWrap.innerHTML = "";
      const poolChords = getAnswerPoolChords();
      poolChords.sort(sortChordIdsCtoB);

      poolChords.forEach(ch => {
        const b = document.createElement("button");
        b.className = "choice";
        b.textContent = ch;
        b.dataset.id = ch;
        b.disabled = true;

        b.addEventListener("click", async () => {
          if ((phase !== "answering" && phase !== "retryPrompt") || !current) return;

          const guess = b.dataset.id;

          // 押した答えの音(root_3)を鳴らす（採点前でも鳴る）
          await playAnswerRoot3(guess);

          // --- 採点確定：答えを押した瞬間 ---
          total += 1;
          if (guess === current.id){
            score += 1;
          }
          totalEl.textContent = String(total);
          scoreEl.textContent = String(score);
          updateAccuracy();

          if (guess === current.id){
            const v = chordVoicingText(current.id, current.invIdx);
            const invTxt = invLabel(current.invIdx);
            setStatus(`⭕ 正解！ ${current.id}（${v}${invTxt ? " / " + invTxt : ""}）`);

            clearHint();
            phase = "idle";
            current = null;

            btnStart.disabled = false;
            btnReplay.disabled = true;
            btnReveal.disabled = true;
            btnHint.disabled = true;

            setReplayLabel();
            setChoicesEnabled(false);
          }else{
            setStatus("❌ 不正解…（再挑戦 / 答え）", true);

            // 不正解直後：再挑戦モード
            phase = "retryPrompt";
            setReplayLabel();

            // まだ同じ問題を継続する
            btnStart.disabled  = true;   // 出題(別問題)はここでは触らせない
            btnReplay.disabled = false;  // 再挑戦
            btnReveal.disabled = false;  // 答え
            btnHint.disabled   = false;  // ヒント
            setChoicesEnabled(true);
          }
        });

        choicesWrap.appendChild(b);
      });
    }

    async function startNewQuestion(){
      const activeBlocks = getActiveBlocks();
      if (activeBlocks.length === 0){
        resetToIdle("アクティブが0です（どれかONにしてください）");
        return;
      }

      const qpool = buildQuestionPool();
      if (qpool.length === 0){
        resetToIdle("出題プールが空です");
        return;
      }

      let picked = null;
      for (let i=0; i<25; i++){
        const c = pickRandom(qpool);
        const ok = await playWithFallback(c);
        if (ok){
          picked = c;
          break;
        }
      }
      if (!picked){
        resetToIdle("音源が見つからず出題できません");
        return;
      }

      current = {
        id: picked.chordId,
        file: picked.file,
        invIdx: picked.invIdx,
        isInv: picked.isInv,
        blockKey: picked.blockKey,
        oct: picked.oct
      };

      phase = "answering";
      setReplayLabel();

      setStatus("出題中：答えを選んでください");
      clearHint();

      btnStart.disabled = true;
      btnReplay.disabled = false; // もう一回
      btnReveal.disabled = false;
      btnHint.disabled = false;

      setChoicesEnabled(true);
    }

    // 出題
    btnStart.addEventListener("click", async () => {
      if (phase !== "idle") return;
      await startNewQuestion();
    });

    // もう一回 / 再挑戦
    btnReplay.addEventListener("click", async () => {
      if (!current) return;

      if (phase === "retryPrompt"){
        // 再挑戦：同一ファイル再生＋再回答中へ
        await playFile(current.file);
        phase = "answering";
        setReplayLabel();
        setStatus("再回答中：答えを選んでください");
        setChoicesEnabled(true);

        // 出題は継続なので押せないまま
        btnStart.disabled = true;
        btnReveal.disabled = false;
        btnHint.disabled = false;
        btnReplay.disabled = false; // もう一回
        return;
      }

      // 通常：聴き直し
      await playFile(current.file);
      // ステータスは変えない
      setChoicesEnabled(true);
      btnReveal.disabled = false;
      btnHint.disabled = false;
    });

    // ヒント
    btnHint.addEventListener("click", () => {
      if (!current) return;
      showHint(makeHint(current.id));
    });

    // 答え（採点はしない。表示して終了）
    btnReveal.addEventListener("click", () => {
      if (!current) return;

      const v = chordVoicingText(current.id, current.invIdx);
      const invTxt = invLabel(current.invIdx);
      setStatus(`答え：${current.id}（${v}${invTxt ? " / " + invTxt : ""}）`);

      phase = "idle";
      current = null;

      btnStart.disabled = false;
      btnReplay.disabled = true;
      btnReveal.disabled = true;
      btnHint.disabled = true;

      setReplayLabel();
      setChoicesEnabled(false);
      clearHint();
    });

    // C（基準音）
    btnC.addEventListener("click", async () => {
      await playFile("C_3.mp3");
    });

    // 初期化
    totalEl.textContent = "0";
    scoreEl.textContent = "0";
    updateAccuracy();

    buildChoices();
    syncAll();
    resetToIdle("待機中");
  })();
  </script>
</body>
</html>
